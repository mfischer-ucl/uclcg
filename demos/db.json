{"jsFiles": ["function setup()\n{\n\tUI = {};\n\tUI.tabs = [];\n\tUI.titleLong = 'Simple Camera';\n\tUI.titleShort = 'cameraSimple';\n\tUI.numFrames = 1000;\n\tUI.maxFPS = 24;\n\tUI.tabs.push(\n\t\t{\n\t\tvisible: true,\n\t\ttype: `x-shader/x-fragment`,\n\t\ttitle: `Ray Generation`,\n\t\tid: `RaytracingDemoFS`,\n\t\tinitialValue: `precision highp float;\n\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\n\nstruct Sphere {\n  vec3 position;\n  float radius;\n};\n\nuniform vec2 g_resolution;\n\nbool intersectSphere(const Sphere sphere, const Ray ray) {\n  vec3 toOrigin = ray.origin - sphere.position;\n  float a = dot(ray.direction, ray.direction);\n  float b = 2.0 * dot(toOrigin, ray.direction);\n  float c = dot(toOrigin, toOrigin) - sphere.radius * sphere.radius;\n  float discriminant = b * b - 4.0 * a * c;\n\n  if(discriminant < 0.0) return false;\n\n  float t0 = (-b - sqrt(discriminant)) / (2.0 * a);\n  float t1 = (-b + sqrt(discriminant)) / (2.0 * a);\n\n  return t0 > 0.0 || t1 > 0.0;\n}\n\nvec3 simpleCamera(const ivec2 pixelCoord) {\n  const int sphereCount = 2;\n\n  // Array of spheres\n  Sphere spheres[sphereCount];\n\n  // Initialize first sphere\n  spheres[0].position = vec3(0, -2, -10);\n  spheres[0].radius = 3.0;\n  // Initialize second sphere\n  spheres[1].position = vec3(3, -1, -5);\n  spheres[1].radius = 1.0;\n\n  float d = 1.0;\n\n  // Initialize a ray\n  Ray ray;\n  ray.origin = vec3(0, 0, d);\n\n  // Construct ray direction\n  vec2 windowMin = vec2(-0.5,-0.5);\n  vec2 windowMax = vec2(0.5,0.5);\n  float width = (windowMax.x - windowMin.x) / g_resolution.x;\n  float height = (windowMax.y - windowMin.y) / g_resolution.y;\n  // Do not need to add 0.5, gl_FragCoord contains pixel centers\n  ray.direction = vec3( windowMin.x + width * gl_FragCoord.x,\n                       \twindowMin.y + height * gl_FragCoord.y,\n                        -d);\n\n  // Correct for window aspect ratio\n  float aspect = g_resolution.x / g_resolution.y;\n  ray.direction = ray.direction * vec3(aspect,1,1);\n\n  // Visualize the direction as a color\n  // return ray.direction;\n\n  // Loop over all spheres\n  for(int i = 0; i < sphereCount; i++) {\n    // Test for intersection\n    if(intersectSphere(spheres[i], ray)) {\n      // Mark as white if it intersects\n      return vec3(1);\n    }\n  }\n  return vec3(0);\n}\n\nvoid main() {\n  gl_FragColor = vec4(simpleCamera(ivec2(gl_FragCoord.xy)), 1);\n}`,\n\t\tdescription: ``,\n\t\twrapFunctionStart: ``,\n\t\twrapFunctionEnd: ``\n\t});\n\n\tUI.tabs.push(\n\t\t{\n\t\tvisible: false,\n\t\ttype: `x-shader/x-vertex`,\n\t\ttitle: `Something we would not like to see`,\n\t\tid: `RaytracingDemoVS`,\n\t\tinitialValue: ` attribute vec3 position;\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n    void main(void) {\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }`,\n\t\tdescription: ``,\n\t\twrapFunctionStart: ``,\n\t\twrapFunctionEnd: ``\n\t});\n\n\t return UI; \n}//!setup\n\nvar gl;\nfunction initGL(canvas) {\n\ttry {\n\t\tgl = canvas.getContext(\"webgl\");\n\t\tgl.viewportWidth = canvas.width;\n\t\tgl.viewportHeight = canvas.height;\n\t} catch (e) {\n\t}\n\tif (!gl) {\n\t\talert(\"Could not initialise WebGL, sorry :-(\");\n\t}\n}\n\nfunction getShader(gl, id) {\n\tvar shaderScript = document.getElementById(id);\n\tif (!shaderScript) {\n\t\treturn null;\n\t}\n\n\tvar str = \"\";\n\tvar k = shaderScript.firstChild;\n\twhile (k) {\n\t\tif (k.nodeType == 3) {\n\t\t\tstr += k.textContent;\n\t\t}\n\t\tk = k.nextSibling;\n\t}\n\n\tvar shader;\n\tif (shaderScript.type == \"x-shader/x-fragment\") {\n\t\tshader = gl.createShader(gl.FRAGMENT_SHADER);\n\t} else if (shaderScript.type == \"x-shader/x-vertex\") {\n\t\tshader = gl.createShader(gl.VERTEX_SHADER);\n\t} else {\n\t\treturn null;\n\t}\n\n\tgl.shaderSource(shader, str);\n\tgl.compileShader(shader);\n\n\tif (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n\t\talert(gl.getShaderInfoLog(shader));\n\t\treturn null;\n\t}\n\n\treturn shader;\n}\n\nfunction RaytracingDemo() {\n}\n\nRaytracingDemo.prototype.initShaders = function() {\n\n\tthis.shaderProgram = gl.createProgram();\n\n\tgl.attachShader(this.shaderProgram, getShader(gl, \"RaytracingDemoVS\"));\n\tgl.attachShader(this.shaderProgram, getShader(gl, \"RaytracingDemoFS\"));\n\tgl.linkProgram(this.shaderProgram);\n\n\tif (!gl.getProgramParameter(this.shaderProgram, gl.LINK_STATUS)) {\n\t\talert(\"Could not initialise shaders\");\n\t}\n\n\tgl.useProgram(this.shaderProgram);\n\n\tthis.shaderProgram.vertexPositionAttribute = gl.getAttribLocation(this.shaderProgram, \"position\");\n\tgl.enableVertexAttribArray(this.shaderProgram.vertexPositionAttribute);\n\n\tthis.shaderProgram.projectionMatrixUniform = gl.getUniformLocation(this.shaderProgram, \"projectionMatrix\");\n    this.shaderProgram.modelviewMatrixUniform = gl.getUniformLocation(this.shaderProgram, \"modelViewMatrix\");\n\n    // Add resolution uniform\n    gl.uniform2f(\n\t\tgl.getUniformLocation(this.shaderProgram, \"g_resolution\"),\n\t\tgetRenderTargetWidth(),\n\t\tgetRenderTargetHeight());\n}\n\nRaytracingDemo.prototype.initBuffers = function() {\n\tthis.triangleVertexPositionBuffer = gl.createBuffer();\n\tgl.bindBuffer(gl.ARRAY_BUFFER, this.triangleVertexPositionBuffer);\n\n\tvar vertices = [\n\t\t -1,  -1,  0,\n\t\t -1,  1,  0,\n\t\t 1,  1,  0,\n\n\t\t -1,  -1,  0,\n\t\t 1,  -1,  0,\n\t\t 1,  1,  0,\n\t ];\n\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n\tthis.triangleVertexPositionBuffer.itemSize = 3;\n\tthis.triangleVertexPositionBuffer.numItems = 3 * 2;\n}\n\nRaytracingDemo.prototype.drawScene = function() {\n\n\tvar perspectiveMatrix = new J3DIMatrix4();\n\tperspectiveMatrix.setUniform(gl, this.shaderProgram.projectionMatrixUniform, false);\n\n\tvar modelViewMatrix = new J3DIMatrix4();\n\tmodelViewMatrix.setUniform(gl, this.shaderProgram.modelviewMatrixUniform, false);\n\n\tgl.bindBuffer(gl.ARRAY_BUFFER, this.triangleVertexPositionBuffer);\n\tgl.vertexAttribPointer(this.shaderProgram.vertexPositionAttribute, this.triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\n\tgl.drawArrays(gl.TRIANGLES, 0, this.triangleVertexPositionBuffer.numItems);\n}\n\nRaytracingDemo.prototype.run = function() {\n\tthis.initShaders();\n\tthis.initBuffers();\n\n\tgl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);\n\tgl.clear(gl.COLOR_BUFFER_BIT);\n\n\tthis.drawScene();\n};\n\nfunction init() {\n\n\n\tenv = new RaytracingDemo();\n\tenv.run();\n\n    return env;\n}\n\nfunction compute(canvas)\n{\n    env.initShaders();\n    env.initBuffers();\n\n    gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    env.drawScene();\n}\n", "function setup()\n{\n\tUI = {};\n\tUI.tabs = [];\n\tUI.titleLong = 'Splines';\n\tUI.titleShort = 'splines';\n\tUI.numFrames = 10000;\n\tUI.maxFPS = 100;\n\tUI.tabs.push(\n\t\t{\n\t\tvisible: true,\n\t\ttype: `x-shader/x-fragment`,\n\t\ttitle: `Fragment Program`,\n\t\tid: `OpenGLDemoFS`,\n\t\tinitialValue: `precision highp float;\n\nvarying vec3 fragColor;\nvarying vec2 fragCoord;\n\nvoid main() {\n  float strip = 20.0;\n  bool xb = fract(fragCoord.x * strip) > 0.5;\n  bool yb = fract(fragCoord.y * strip) > 0.5;\n\n  gl_FragColor.rgb = fragColor * (xb == yb ? 0.7 : 1.0);\n  \n  gl_FragColor.a = 1.0;  \n}`,\n\t\tdescription: ``,\n\t\twrapFunctionStart: ``,\n\t\twrapFunctionEnd: ``\n\t});\n\n\tUI.tabs.push(\n\t\t{\n\t\tvisible: true,\n\t\ttype: `x-shader/x-vertex`,\n\t\ttitle: `Vertex Program`,\n\t\tid: `OpenGLDemoVS`,\n\t\tinitialValue: `attribute vec2 coord;\n\nvarying vec3 fragColor;\nvarying vec2 fragCoord;\n\nuniform float time;\n\nmat4 computeProjectionMatrix(float fov, float aspect, float zNear, float zFar) { \n\tfloat deltaZ = zFar - zNear;\n\tfloat cotangent = cos(fov * 0.5) / sin(fov * 0.5);\n\t\n  \tmat4 projectionMatrix;\n  \tprojectionMatrix[0] = vec4(cotangent / aspect, 0.0, 0.0, 0.0);\n\tprojectionMatrix[1] = vec4(0.0, cotangent, 0.0, 0.0);\n\tprojectionMatrix[2] = vec4(0.0, 0.0, -(zFar + zNear) / deltaZ, -1.0);\n\tprojectionMatrix[3] = vec4(0.0, 0.0, -2.0 * zNear * zFar / deltaZ, 0.0);\n  \n\treturn projectionMatrix;\n}\n\n// Used to generate a simple \"look-at\" camera. \nmat4 computeViewMatrix(vec3 VRP, vec3 TP, vec3 VUV) {\t\t\n  \t// The VPN is pointing away from the TP. Can also be modeled the other way around.\n  \tvec3 VPN = VRP - TP;\n  \t// Generate the camera axes.\n    vec3 n = normalize(VPN);\n    vec3 u = normalize(cross(VUV, n));\n    vec3 v = normalize(cross(n, u));\n    \n\tmat4 modelViewMatrix;\n\tmodelViewMatrix[0] = vec4(u[0], v[0], n[0], 0);\n\tmodelViewMatrix[1] = vec4(u[1], v[1], n[1], 0);\n\tmodelViewMatrix[2] = vec4(u[2], v[2], n[2], 0);\n\tmodelViewMatrix[3] = vec4(- dot(VRP, u), - dot(VRP, v), - dot(VRP, n), 1);\n  \n  \treturn modelViewMatrix;\n}\n\nvec3 linearBezier1D(vec3 y0, vec3 y1, float coord) {  \n  return mix(y0, y1, coord);\n}\n\nvec3 qudraticBezier1D(vec3 y0, vec3 y1, vec3 y2, float coord) {  \n  return linearBezier1D(linearBezier1D(y0, y1, coord), linearBezier1D(y1, y2, coord), coord);\n}\n\nstruct Patch2 {\n  vec3 controlPoints[2 * 2];\n};\n\nstruct Patch3 {\n  vec3 controlPoints[3 * 3 ];\n};\n\nvec3 linearBezier2D(const vec2 coord, const Patch2 patch2) {   \n  return \n    linearBezier1D(\n    \tlinearBezier1D(patch2.controlPoints[0], patch2.controlPoints[1], coord.s),\n  \t\tlinearBezier1D(patch2.controlPoints[2], patch2.controlPoints[3], coord.s),\n      \tcoord.t);\n}\n\nvec3 qudraticBezier2D(const vec2 coord, const Patch3 patch3) {  \n  return \n    qudraticBezier1D(\n    \tqudraticBezier1D(\n      \t\tpatch3.controlPoints[0 * 3 + 0], \n      \t\tpatch3.controlPoints[0 * 3 + 1], \n      \t\tpatch3.controlPoints[0 * 3 + 2], coord.s),\n  \t\tqudraticBezier1D(\n      \t\tpatch3.controlPoints[1 * 3 + 0], \n      \t\tpatch3.controlPoints[1 * 3 + 1], \n      \t\tpatch3.controlPoints[1 * 3 + 2], coord.s),\n      \tqudraticBezier1D(\n      \t\tpatch3.controlPoints[2 * 3 + 0], \n      \t\tpatch3.controlPoints[2 * 3 + 1], \n      \t\tpatch3.controlPoints[2 * 3 + 2], coord.s),\n      \tcoord.t);\n}\n\nvec3 spline(const vec2 coord) {  \n\n  Patch2 patch2;\n  patch2.controlPoints[0] = vec3(0.0, -1.0, 0.0);\n  patch2.controlPoints[1] = vec3(1.0, 0.0, 0.0);\n  patch2.controlPoints[2] = vec3(0.0, 1.0, 1.0);  \n  patch2.controlPoints[3] = vec3(1.0, 0.0, 1.0);\n\n  patch2.controlPoints[2 * 1 + 1].y = 2.0 * sin(1.0 * time);  \n  patch2.controlPoints[2 * 0 + 0].y = 3.0 * cos(2.0 * time);\n  \n  //return linearBezier2D(coord, patch2);\n  \n  Patch3 patch3;\n  patch3.controlPoints[3 * 0 + 0] = vec3(0.0, 0.0, 0.0);\n  patch3.controlPoints[3 * 0 + 1] = vec3(0.5, 0.0, 0.0);\n  patch3.controlPoints[3 * 0 + 2] = vec3(1.0, 0.0, 0.0);\n  patch3.controlPoints[3 * 1 + 0] = vec3(0.0, 0.0, 0.5);\n  patch3.controlPoints[3 * 1 + 1] = vec3(0.5, 4.0, 0.5);\n  patch3.controlPoints[3 * 1 + 2] = vec3(1.0, 0.0, 0.5);\n  patch3.controlPoints[3 * 2 + 0] = vec3(0.0, 0.0, 1.0);\n  patch3.controlPoints[3 * 2 + 1] = vec3(0.5, 0.0, 1.0);\n  patch3.controlPoints[3 * 2 + 2] = vec3(1.0, 0.0, 1.0);\n  \n  patch3.controlPoints[3 * 1 + 1].y = 2.0 * sin(1.0 * time);  \n  patch3.controlPoints[3 * 0 + 0].y = 3.0 * cos(2.0 * time);\n    \n  return qudraticBezier2D(coord, patch3);\n}\n\nvoid main(void) {\n  vec3 TP = vec3(0, 0, 0);\n  vec3 VRP = 5.0 * vec3(sin(time), 0, cos(time)) + vec3(0, 3.0, 0);\n  vec3 VUV = vec3(0, 1, 0); \n  mat4 viewMatrix = computeViewMatrix(VRP, TP, VUV); \n  \n  mat4 projectionMatrix = computeProjectionMatrix(0.6, 2.0, 0.5, 200.0);  \n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(vec3(3, 1, 3) * (spline(coord) - 0.5), 1.0);\n  fragColor = coord.x * vec3(1, 0.5, 0.1) + coord.y * vec3(0.1, 0.5, 0.9);\n  fragCoord = coord;\n}`,\n\t\tdescription: ``,\n\t\twrapFunctionStart: ``,\n\t\twrapFunctionEnd: ``\n\t});\n\n\tUI.tabs.push(\n\t\t{\n\t\tvisible: true,\n\t\ttype: `text/javascript`,\n\t\ttitle: `OpenGL`,\n\t\tid: `DemoJS`,\n\t\tinitialValue: `var resolution = 40;\n\nfunction domain(i) {\n  return (i / resolution);\n}\n\nfunction index(i, j, vertex, dimension ) {\n  return (i * resolution + j) * 2 * 3 * 2 + 2 * vertex + dimension;\n}\n\nfunction getVertices() {\n  var result = new Float32Array(2 * 3 * 2 * resolution * resolution);\n  for(i = 0; i < resolution; i++) {\n  \tfor(j = 0; j < resolution; j++) {\n      \t// First tri\n      \tresult[index(i, j, 0, 0)] = domain(j + 0);\n      \tresult[index(i, j, 0, 1)] = domain(i + 0);\n      \tresult[index(i, j, 1, 0)] = domain(j + 1);\n      \tresult[index(i, j, 1, 1)] = domain(i + 0);\n        result[index(i, j, 2, 0)] = domain(j + 0);\n      \tresult[index(i, j, 2, 1)] = domain(i + 1);\n      \tresult[index(i, j, 3, 0)] = domain(j + 1);\n      \tresult[index(i, j, 3, 1)] = domain(i + 0);      \t\n      \tresult[index(i, j, 4, 0)] = domain(j + 0);\n      \tresult[index(i, j, 4, 1)] = domain(i + 1);\n        result[index(i, j, 5, 0)] = domain(j + 1);\n      \tresult[index(i, j, 5, 1)] = domain(i + 1);\n\t}\n  }\n  \n  return result;\n}\n\nfunction loadShaders() {\n  shaderProgram = gl.createProgram();\n\n  gl.attachShader(shaderProgram, getShader(gl, \"OpenGLDemoVS\"));\n  gl.attachShader(shaderProgram, getShader(gl, \"OpenGLDemoFS\"));\n  gl.linkProgram(shaderProgram);\n\n  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n    alert(\"Could not initialise shaders\");\n  }\n\n  gl.useProgram(shaderProgram);\n}\n\nfunction loadGeometry() {\n  // Positions\n  positionBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(getVertices()), gl.STATIC_DRAW);\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n  var positionAttributeLocation = gl.getAttribLocation(shaderProgram, \"coord\");\n  gl.enableVertexAttribArray(positionAttributeLocation);\n  gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false,  0,   0);\n}\n\nfunction draw() {  \n  gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);  \n  gl.clearColor(0.3, 0.3, 0.3, 1.0);\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n  gl.enable(gl.DEPTH_TEST);\n  gl.disable(gl.CULL_FACE);\n  gl.uniform1f(gl.getUniformLocation(shaderProgram, \"time\"), getTime());  \n  gl.drawArrays(gl.TRIANGLES, 0, 2 * 3 * resolution * resolution);  \n}\n\nif(hasCodeChanged()) {\n  // Initialization\n  loadShaders();\n  loadGeometry();  \n}\n\ndraw();\n\n`,\n\t\tdescription: ``,\n\t\twrapFunctionStart: ``,\n\t\twrapFunctionEnd: ``\n\t});\n\n\t return UI; \n}//!setup\n\nvar gl;\nfunction initGL(canvas) {\n\ttry {\n\t\tgl = canvas.getContext(\"webgl\");\n\t\tgl.viewportWidth = canvas.width;\n\t\tgl.viewportHeight = canvas.height;\n\t} catch (e) {\n\t}\n\tif (!gl) {\n\t\talert(\"Could not initialise WebGL, sorry :-(\");\n\t}\n}\n\nfunction getShader(gl, id) {\n\tvar shaderScript = document.getElementById(id);\t\n\tif (!shaderScript) {\n\t\treturn null;\n\t}\n\n\tvar str = \"\";\n\tvar k = shaderScript.firstChild;\n\twhile (k) {\n\t\tif (k.nodeType == 3) {\n\t\t\tstr += k.textContent;\n\t\t}\n\t\tk = k.nextSibling;\n\t}\n\n\tvar shader;\n\tif (shaderScript.type == \"x-shader/x-fragment\") {\n\t\tshader = gl.createShader(gl.FRAGMENT_SHADER);\n\t} else if (shaderScript.type == \"x-shader/x-vertex\") {\n\t\tshader = gl.createShader(gl.VERTEX_SHADER);\n\t} else {\n\t\treturn null;\n\t}\n\n\tgl.shaderSource(shader, str);\n\tgl.compileShader(shader);\n\n\tif (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n\t\talert(gl.getShaderInfoLog(shader));\n\t\treturn null;\n\t}\n\n\treturn shader;\n}\n\n\nfunction evalJS(id) {\n\t\n\ttry {\n\t\teval(document.getElementById(id).innerHTML);\n\t} catch (e) {\n\t\t\talert(e.message);\n\t}\t  \n}\n\nvar count = 0;\nfunction getTime() {  \nvar d = new Date();\nreturn d.getMinutes() * 60.0 + d.getSeconds() + d.getMilliseconds() / 1000.0;\n}\n\nfunction init() {\t\nloadShaders();\nloadGeometry();\n}\n\nfunction compute(canvas) {\n\tevalJS(\"DemoJS\");\n}\n", "function setup()\n{\n\tUI = {};\n\tUI.tabs = [];\n\tUI.titleLong = 'OpenGL';\n\tUI.titleShort = 'openGL';\n\tUI.numFrames = 1000;\n\tUI.maxFPS = 24;\n\tUI.tabs.push(\n\t\t{\n\t\tvisible: true,\n\t\ttype: `x-shader/x-fragment`,\n\t\ttitle: `Fragment Program`,\n\t\tid: `OpenGLDemoFS`,\n\t\tinitialValue: `precision highp float;\n\n// Incoming from the vertex shader\nvarying vec3 fragColor;\nvarying vec3 fragNormal;\nvarying vec3 fragPosition;\nvarying vec2 fragTexCoord;\nvarying vec3 cameraPosition;\n\nuniform sampler2D testTexture;\n\nvoid main() {\n\n  // Light parameters\n  vec3 ambientLightColor = vec3(0.2, 0.2, 0.3);\n  vec3 lightPosition = vec3(0.0, 16.0, -30.0);\n  vec3 lightColor = vec3(1.0, 0.8, 0.9);\n\n  // Material parameters\n  vec3 materialKa = fragColor;\n  vec3 materialKd = vec3(1.0, 1.0, 1.0) * fragColor;\n  vec3 materialKs = vec3(0.8, 0.8, 0.8);\n  float materialGlossiness = 20.0;\n\n  // Articulate material parameters by textures\n  //vec3 textureColor =  texture2D(testTexture, fragTexCoord).rgb;\n  //materialKa *= textureColor;\n  //materialKd *= textureColor;\n  //materialKs *= textureColor;\n\n  // Directions used for shading\n  vec3 L = normalize(lightPosition.xyz - fragPosition.xyz);\n  vec3 E = normalize(cameraPosition - fragPosition.xyz);\n  vec3 R = normalize(-reflect(L, fragNormal.xyz));\n\n  // Phong, written as diffuse and specular reflectance\n  vec3 diffuseReflectance = materialKd * max(dot(fragNormal.xyz, L), 0.0);\n  vec3 specularReflectance = materialKs * pow(max(dot(R, E), 0.0), materialGlossiness);\n\n  // Incoming light times reflectance is outgoing light, also add some ambient\n  vec3 color =\n    ambientLightColor * materialKa +\n    lightColor * (diffuseReflectance + specularReflectance);\n\n  gl_FragColor = vec4(color, 1.0);\n\n  // Visualize the tex coord\n  //gl_FragColor = vec4(fragTexCoord, 0, 1);\n\n  // Use texture\n  //gl_FragColor = vec4(texture2D(testTexture, fragTexCoord).rgb, 1);\n}`,\n\t\tdescription: ``,\n\t\twrapFunctionStart: ``,\n\t\twrapFunctionEnd: ``\n\t});\n\n\tUI.tabs.push(\n\t\t{\n\t\tvisible: true,\n\t\ttype: `x-shader/x-vertex`,\n\t\ttitle: `Vertex Program`,\n\t\tid: `OpenGLDemoVS`,\n\t\tinitialValue: `// Incoming from the array buffers\nattribute vec3 position;\nattribute vec3 color;\nattribute vec3 normal;\nattribute vec2 texCoord;\n\n// Outgoing to the fragment program\nvarying vec3 fragColor;\nvarying vec3 fragNormal;\nvarying vec3 fragPosition;\nvarying vec2 fragTexCoord;\nvarying vec3 cameraPosition;\n\n// The current time value, set in the rick() of the JS code\nuniform float time;\n\nmat4 computeProjectionMatrix(float fov, float aspect, float zNear, float zFar) {\n\n\tfloat deltaZ = zFar - zNear;\n\tfloat cotangent = cos(fov * 0.5) / sin(fov * 0.5);\n\n  \tmat4 projectionMatrix;\n  \tprojectionMatrix[0] = vec4(cotangent / aspect, 0.0, 0.0, 0.0);\n\tprojectionMatrix[1] = vec4(0.0, cotangent, 0.0, 0.0);\n\tprojectionMatrix[2] = vec4(0.0, 0.0, -(zFar + zNear) / deltaZ, -1.0);\n\tprojectionMatrix[3] = vec4(0.0, 0.0, -2.0 * zNear * zFar / deltaZ, 0.0);\n\n\treturn projectionMatrix;\n}\n\n// Used to generate a simple \"look-at\" camera.\nmat4 computeViewMatrix(vec3 VRP, vec3 TP, vec3 VUV) {\n  \t// The VPN is pointing away from the TP. Can also be modeled the other way around.\n  \tvec3 VPN = VRP - TP;\n  \t// Generate the camera axes.\n    vec3 n = normalize(VPN);\n    vec3 u = normalize(cross(VUV, n));\n    vec3 v = normalize(cross(n, u));\n\n\tmat4 modelViewMatrix;\n\tmodelViewMatrix[0] = vec4(u[0], v[0], n[0], 0);\n\tmodelViewMatrix[1] = vec4(u[1], v[1], n[1], 0);\n\tmodelViewMatrix[2] = vec4(u[2], v[2], n[2], 0);\n\tmodelViewMatrix[3] = vec4(- dot(VRP, u), - dot(VRP, v), - dot(VRP, n), 1);\n\n  \treturn modelViewMatrix;\n}\n\nvoid main(void) {\n  // Animate the camera position using a uniform variable\n  cameraPosition = 5.0 * vec3(sin(time), 0, cos(time)) + vec3(0, 3.0, 0);\n\n  // Animate each vertex position\n  vec3 position2 = position +\n    0.0 * 0.2 * vec3(\n      sin(0.4 * position.x + time * 0.5),\n      cos(0.6 * position.x + time * 0.2),\n      sin(0.8 * position.x + time * 0.3)\n    );\n\n  // Set the parameters for the look-at camera.\n  vec3 TP = vec3(0, 0, 0);\n  vec3 VRP = cameraPosition;\n  vec3 VUV = vec3(0, 1, 0);\n\n  // Compute the view matrix (covered in the slides).\n  mat4 viewMatrix = computeViewMatrix(VRP, TP, VUV);\n\n  // Compute the projection matrix. NOTE: this is not covered in general camera slides.\n  mat4 projectionMatrix = computeProjectionMatrix(0.6, 2.0, 0.5, 200.0);\n\n  // A vertex shader *must* write to this value, otherwise the vertex wil not know where to go on screen\n  gl_Position = projectionMatrix * viewMatrix * vec4(position2, 1.0);\n\n  // Pass on information to the fragment program\n  fragColor = color;\n  fragNormal = normal;\n  fragPosition = position;\n  fragTexCoord = texCoord;\n}`,\n\t\tdescription: ``,\n\t\twrapFunctionStart: ``,\n\t\twrapFunctionEnd: ``\n\t});\n\n\tUI.tabs.push(\n\t\t{\n\t\tvisible: true,\n\t\ttype: `text/javascript`,\n\t\ttitle: `OpenGL`,\n\t\tid: `DemoJS`,\n\t\tinitialValue: `function getVertices() {\n  var size = 1.0;\n  return [\n    // Front face\n    -size, -size,  -size,\n    +size, -size,  -size,\n    +size, +size,  -size,\n    -size, +size,  -size,\n\n    // Back face\n    -size, -size, +size,\n    -size, +size, +size,\n    +size, +size, +size,\n    +size, -size, +size,\n\n    // Front face\n    -size, -size,  -size,\n    +size, -size,  -size,\n    +size, -size,  +size,\n    -size, -size,  +size,\n\n    // Back face\n    -size, +size, -size,\n    -size, +size, +size,\n    +size, +size, +size,\n    +size, +size, -size,\n\n    // Front face\n    -size, -size,  -size,\n    -size, -size,  +size,\n    -size, +size,  +size,\n    -size, +size,  -size,\n\n    // Back face\n    +size, -size, +size,\n    +size, +size, +size,\n    +size, +size, -size,\n    +size, -size, -size,\n  ];\n}\n\nfunction getColors() {\n return [\n   // Front face\n   1.0, 0.7, 0.0,\n   1.0, 0.7, 0.0,\n   1.0, 0.7, 0.0,\n   1.0, 0.7, 0.0,\n   // Back face\n   0.0, 1.0, 0.2,\n   0.0, 1.0, 0.2,\n   0.0, 1.0, 0.2,\n   0.0, 1.0, 0.2,\n   // Top face\n   0.4, 0.1, 1.0,\n   0.4, 0.1, 1.0,\n   0.4, 0.1, 1.0,\n   0.4, 0.1, 1.0,\n   // Bottom fac\n   1.0, 0.6, 0.3,\n   1.0, 0.6, 0.3,\n   1.0, 0.6, 0.3,\n   1.0, 0.6, 0.3,\n   // Right\n   0.0, 0.7, 1.0,\n   0.0, 0.7, 1.0,\n   0.0, 0.7, 1.0,\n   0.0, 0.7, 1.0,\n   // Left\n   1.0, 0.0, 1.0,\n   1.0, 0.0, 1.0,\n   1.0, 0.0, 1.0,\n   1.0, 0.0, 1.0\n ];\n}\n\nfunction getNormals() {\n    return [\n      // Front face\n      0.0, 0.0, 1.0,\n      0.0, 0.0, 1.0,\n      0.0, 0.0, 1.0,\n      0.0, 0.0, 1.0,\n      // Back face\n      0.0, 0.0, -1.0,\n      0.0, 0.0, -1.0,\n      0.0, 0.0, -1.0,\n      0.0, 0.0, -1.0,\n      // Top face\n      0.0, 1.0, 0.0,\n      0.0, 1.0, 0.0,\n      0.0, 1.0, 0.0,\n      0.0, 1.0, 0.0,\n      // Bottom face\n      0.0, -1.0, 0.0,\n      0.0, -1.0, 0.0,\n      0.0, -1.0, 0.0,\n      0.0, -1.0, 0.0,\n      // Right\n      1.0, 0.0, 0.0,\n      1.0, 0.0, 0.0,\n      1.0, 0.0, 0.0,\n      1.0, 0.0, 0.0,\n      // Left\n      -1.0, 0.0, 0.0,\n      -1.0, 0.0, 0.0,\n      -1.0, 0.0, 0.0,\n      -1.0, 0.0, 0.0\n    ];\n}\n\nfunction getTexCoords() {\nreturn [\n      // Front face\n      0.0, 0.0,\n      1.0, 0.0,\n      1.0, 1.0,\n      0.0, 1.0,\n\n      // Back face\n      1.0, 0.0,\n      1.0, 1.0,\n      0.0, 1.0,\n      0.0, 0.0,\n\n      // Top face\n      0.0, 1.0,\n      0.0, 0.0,\n      1.0, 0.0,\n      1.0, 1.0,\n\n      // Bottom face\n      1.0, 1.0,\n      0.0, 1.0,\n      0.0, 0.0,\n      1.0, 0.0,\n\n      // Right face\n      1.0, 0.0,\n      1.0, 1.0,\n      0.0, 1.0,\n      0.0, 0.0,\n\n      // Left face\n      0.0, 0.0,\n      1.0, 0.0,\n      1.0, 1.0,\n      0.0, 1.0,\n    ];\n}\n\nfunction getIndices() {\n    return [\n      2, 1, 0,      3, 2, 0,    // Front face\n      6, 5, 4,      7, 6, 4,    // Back face\n      8, 9, 10,     8, 10, 11,  // Top face\n      12, 13, 14,   12, 14, 15, // Bottom face\n      16, 17, 18,   16, 18, 19, // Right face\n      22, 21, 20,   23, 22, 20  // Left face\n    ];\n}\n\nfunction loadShaders() {\n  shaderProgram = gl.createProgram();\n\n  gl.attachShader(shaderProgram, getShader(gl, \"OpenGLDemoVS\"));\n  gl.attachShader(shaderProgram, getShader(gl, \"OpenGLDemoFS\"));\n  gl.linkProgram(shaderProgram);\n\n  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n    alert(\"Could not initialise shaders\");\n  }\n\n  gl.useProgram(shaderProgram);\n}\n\nfunction loadGeometry() {\n  // Positions\n  positionBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(getVertices()), gl.STATIC_DRAW);\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n  var positionAttributeLocation = gl.getAttribLocation(shaderProgram, \"position\");\n  gl.enableVertexAttribArray(positionAttributeLocation);\n  gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false,  0,   0);\n\n  // Colors\n  colorBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(getColors()), gl.STATIC_DRAW);\n  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\n  var colorAttributeLocation = gl.getAttribLocation(shaderProgram, \"color\");\n  gl.enableVertexAttribArray(colorAttributeLocation);\n  gl.vertexAttribPointer(colorAttributeLocation, 3, gl.FLOAT, false, 0, 0);\n\n  // Normals\n  normalBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(getNormals()), gl.STATIC_DRAW);\n  gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);\n  var normalAttributeLocation = gl.getAttribLocation(shaderProgram, \"normal\");\n  gl.enableVertexAttribArray(normalAttributeLocation);\n  gl.vertexAttribPointer(normalAttributeLocation, 3, gl.FLOAT,  false,  0,  0);\n\n  // Texture Coords (UVs)\n  texCoordBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(getTexCoords()), gl.STATIC_DRAW);\n  gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);\n  var texCoordAttributeLocation = gl.getAttribLocation(shaderProgram, \"texCoord\");\n  gl.enableVertexAttribArray(texCoordAttributeLocation);\n  gl.vertexAttribPointer(texCoordAttributeLocation, 2, gl.FLOAT,  false,  0,  0);\n\n  // Indices\n  triangleBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, triangleBuffer);\n  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(getIndices()), gl.STATIC_DRAW);\n  triangleBuffer.itemSize = 1;\n  triangleBuffer.numItems = 2 * 3 * 6;\n}\n\nfunction draw() {\n\n  gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);\n\n  gl.clearColor(0.3, 0.3, 0.3, 1.0);\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n  //gl.disable(gl.DEPTH_TEST);\n  gl.enable(gl.DEPTH_TEST);\n\n  gl.disable(gl.CULL_FACE);\n  //gl.enable(gl.CULL_FACE);\n\n  gl.cullFace(gl.BACK);\n  //gl.cullFace(gl.FRONT);\n\n  gl.disable(gl.BLEND);\n  //gl.enable(gl.BLEND);\n\n  gl.blendFunc(gl.ONE, gl.ONE);\n\n  // Use the texture \"texture\"\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n\n  // Update the uniform variable \"time\" with the current time\n  // getTime is implemented by our framework and returns time in milliseconds\n  gl.uniform1f(gl.getUniformLocation(shaderProgram, \"time\"), getTime());\n\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, triangleBuffer);\n  gl.drawElements(gl.TRIANGLES, triangleBuffer.numItems, gl.UNSIGNED_SHORT, 0);\n}\n\n// This function is caled once the image finished loading\nfunction handleLoadedTexture(texture) {\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, texture.image);\n  gl.generateMipmap(gl.TEXTURE_2D);\n  gl.bindTexture(gl.TEXTURE_2D, null);\n}\n\nfunction loadTexture() {\n  gl.enable(gl.TEXTURE_2D);\n  texture  = gl.createTexture();\n\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n  // Linear filtering\n  //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n\n  // MIP  filtering\n  //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n\n  // Load texture from memory\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([\n    10, 50, 200, 255,\n    10, 100, 50, 255,\n    10, 20, 30, 255,\n    200, 50, 100, 255,\n  ]));\n\n  // Load texture.\n  // .image is a HTML image we add to the variable to be used once it had finished loading\n  texture.image = new Image();\n  texture.image.onload = function() {\n    handleLoadedTexture(texture);\n  }\n  //texture.image.src = \"http://cg.cs.ucl.ac.uk/images/texture.jpg\";\n}\n\nfunction tick() {\n  // Draw the scene\n  draw();\n\n  // Requests this function to be called on the next possible occasion\n  // This is a HTML function, not anything WebGL-specific\n  requestAnimationFrame(tick);\n}\n\n// Initialization\nloadShaders();\nloadGeometry();\nloadTexture();\n\n// Request to tick. tick() itself will ask HTML to be called again\nif (!tickHasBeenCalled) {\n\ttickHasBeenCalled = true;\n\ttick();\n}\n`,\n\t\tdescription: ``,\n\t\twrapFunctionStart: ``,\n\t\twrapFunctionEnd: ``\n\t});\n\n\t return UI; \n}//!setup\n\nvar gl;\nfunction initGL(canvas) {\n\ttry {\n\t\tgl = canvas.getContext(\"webgl\");\n\t\tgl.viewportWidth = canvas.width;\n\t\tgl.viewportHeight = canvas.height;\n\t} catch (e) {\n\t}\n\tif (!gl) {\n\t\talert(\"Could not initialise WebGL, sorry :-(\");\n\t}\n}\n\nfunction getShader(gl, id) {\n\tvar shaderScript = document.getElementById(id);\n\tif (!shaderScript) {\n\t\treturn null;\n\t}\n\n\tvar str = \"\";\n\tvar k = shaderScript.firstChild;\n\twhile (k) {\n\t\tif (k.nodeType == 3) {\n\t\t\tstr += k.textContent;\n\t\t}\n\t\tk = k.nextSibling;\n\t}\n\n\tvar shader;\n\tif (shaderScript.type == \"x-shader/x-fragment\") {\n\t\tshader = gl.createShader(gl.FRAGMENT_SHADER);\n\t} else if (shaderScript.type == \"x-shader/x-vertex\") {\n\t\tshader = gl.createShader(gl.VERTEX_SHADER);\n\t} else {\n\t\treturn null;\n\t}\n\n\tgl.shaderSource(shader, str);\n\tgl.compileShader(shader);\n\n\tif (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n\t\talert(gl.getShaderInfoLog(shader));\n\t\treturn null;\n\t}\n\n\treturn shader;\n}\n\nfunction RaytracingDemo() {\n}\n\nfunction evalJS(id) {\n\n\ttry {\n\t\teval(document.getElementById(id).innerHTML);\n\t} catch (e) {\n\t\t\talert(e.message);\n\t}\n}\n\nvar count = 0;\nfunction getTime() {\nvar d = new Date();\nreturn d.getMinutes() * 60.0 + d.getSeconds() + d.getMilliseconds() / 1000.0;\n}\n\nvar tickHasBeenCalled = false;\nfunction init() {\n}\n\nfunction compute(canvas) {\n\tevalJS(\"DemoJS\");\n}\n", "function setup()\n{\n\tUI = {};\n\tUI.tabs = [];\n\tUI.titleLong = 'Ray Tracer';\n\tUI.titleShort = 'RayTracerSimple';\n\tUI.numFrames = 1000;\n\tUI.maxFPS = 24;\n\tUI.renderWidth = 800;\n\tUI.renderHeight = 400;\n\n\tUI.tabs.push(\n\t\t{\n\t\tvisible: true,\n\t\ttype: `x-shader/x-fragment`,\n\t\ttitle: `RaytracingDemoFS - GL`,\n\t\tid: `RaytracingDemoFS`,\n\t\tinitialValue: `//#define SOLUTION_CYLINDER_AND_PLANE\n//#define SOLUTION_MATERIAL\n//#define SOLUTION_SHADOW\n//#define SOLUTION_REFLECTION_REFRACTION\n//#define SOLUTION_FRESNEL\n\nprecision highp float;\nuniform ivec2 viewport; \n\nstruct PointLight {\n  vec3 position;\n  vec3 color;\n};\n\nstruct Material {\n  vec3  diffuse;\n  vec3  specular;\n  float glossiness;\n#ifdef SOLUTION_MATERIAL\n  // Put the variables for reflection and refraction here\n#else\n#endif\n};\n\nstruct Sphere {\n  vec3 position;\n  float radius;\n  Material material;\n};\n\nstruct Plane {\n  vec3 normal;\n  float d;\n  Material material;\n};\n\nstruct Cylinder {\n  vec3 position;\n  vec3 direction;  \n  float radius;\n  Material material;\n};\n\nconst int lightCount = 2;\nconst int sphereCount = 3;\nconst int planeCount = 1;\nconst int cylinderCount = 2;\n\nstruct Scene {\n  vec3 ambient;\n  PointLight[lightCount] lights;\n  Sphere[sphereCount] spheres;\n  Plane[planeCount] planes;\n  Cylinder[cylinderCount] cylinders;\n};\n\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\n\n// Contains all information pertaining to a ray/object intersection\nstruct HitInfo {\n  bool hit;\n  float t;\n  vec3 position;\n  vec3 normal;\n  Material material;\n  bool enteringPrimitive;\n};\n\nHitInfo getEmptyHit() {\n  return HitInfo(\n    false, \n    0.0, \n    vec3(0.0), \n    vec3(0.0), \n#ifdef SOLUTION_MATERIAL\n#else\n  \t// Depending on the material definition extension you make, this constructor call might need to be extened as well\n    Material(vec3(0.0), vec3(0.0), 0.0),\n#endif\n    false);\n}\n\n// Sorts the two t values such that t1 is smaller than t2\nvoid sortT(inout float t1, inout float t2) {\n  // Make t1 the smaller t\n  if(t2 < t1)  {\n    float temp = t1;\n    t1 = t2;\n    t2 = temp;\n  }\n}\n\n// Tests if t is in an interval\nbool isTInInterval(const float t, const float tMin, const float tMax) {\n  return t > tMin && t < tMax;\n}\n\n// Get the smallest t in an interval\nbool getSmallestTInInterval(float t0, float t1, const float tMin, const float tMax, inout float smallestTInInterval) {\n  \n  sortT(t0, t1);\n  \n  // As t0 is smaller, test this first\n  if(isTInInterval(t0, tMin, tMax)) {\n  \tsmallestTInInterval = t0;\n    return true;\n  }\n  \n  // If t0 was not in the interval, still t1 could be\n  if(isTInInterval(t1, tMin, tMax)) {\n  \tsmallestTInInterval = t1;\n    return true;\n  }  \n  \n  // None was\n  return false;\n}\n\nHitInfo intersectSphere(const Ray ray, const Sphere sphere, const float tMin, const float tMax) {\n              \n    vec3 to_sphere = ray.origin - sphere.position;\n  \n    float a = dot(ray.direction, ray.direction);\n    float b = 2.0 * dot(ray.direction, to_sphere);\n    float c = dot(to_sphere, to_sphere) - sphere.radius * sphere.radius;\n    float D = b * b - 4.0 * a * c;\n    if (D > 0.0)\n    {\n\t\tfloat t0 = (-b - sqrt(D)) / (2.0 * a);\n\t\tfloat t1 = (-b + sqrt(D)) / (2.0 * a);\n      \n      \tfloat smallestTInInterval;\n      \tif(!getSmallestTInInterval(t0, t1, tMin, tMax, smallestTInInterval)) {\n          return getEmptyHit();\n        }\n      \n      \tvec3 hitPosition = ray.origin + smallestTInInterval * ray.direction;      \n\t\t\n\t\t//Checking if we're inside the sphere by checking if the ray's origin is inside. If we are, then the normal \n\t\t//at the intersection surface points towards the center. Otherwise, if we are outside the sphere, then the normal \n\t\t//at the intersection surface points outwards from the sphere's center. This is important for refraction.\n      \tvec3 normal = \n          \tlength(ray.origin - sphere.position) < sphere.radius + 0.001? \n          \t-normalize(hitPosition - sphere.position): \n      \t\tnormalize(hitPosition - sphere.position);      \n\t\t\n\t\t//Checking if we're inside the sphere by checking if the ray's origin is inside, but this time for IOR bookkeeping. \n\t\t//If we are inside, set a flag to say we're leaving. If we are outside, set the flag to say we're entering.\n\t\t//This is also important for refraction.\n\t\tbool enteringPrimitive = \n          \tlength(ray.origin - sphere.position) < sphere.radius + 0.001? \n          \tfalse:\n\t\t    true; \n\n        return HitInfo(\n          \ttrue,\n          \tsmallestTInInterval,\n          \thitPosition,\n          \tnormal,\n          \tsphere.material,\n\t\t\tenteringPrimitive);\n    }\n    return getEmptyHit();\n}\n\nHitInfo intersectPlane(const Ray ray,const Plane plane, const float tMin, const float tMax) {\n#ifdef SOLUTION_CYLINDER_AND_PLANE\n#endif  \n    return getEmptyHit();\n}\n\nfloat lengthSquared(vec3 x) {\n  return dot(x, x);\n}\n\nHitInfo intersectCylinder(const Ray ray, const Cylinder cylinder, const float tMin, const float tMax) {\n#ifdef SOLUTION_CYLINDER_AND_PLANE\n#endif  \n    return getEmptyHit();\n}\n\nHitInfo getBetterHitInfo(const HitInfo oldHitInfo, const HitInfo newHitInfo) {\n\tif(newHitInfo.hit)\n  \t\tif(newHitInfo.t < oldHitInfo.t)  // No need to test for the interval, this has to be done per-primitive\n          return newHitInfo;\n  \treturn oldHitInfo;\n}\n\nHitInfo intersectScene(const Scene scene, const Ray ray, const float tMin, const float tMax) {\n  HitInfo bestHitInfo;\n  bestHitInfo.t = tMax;\n  bestHitInfo.hit = false;\n  for (int i = 0; i < cylinderCount; ++i) {\n    bestHitInfo = getBetterHitInfo(bestHitInfo, intersectCylinder(ray, scene.cylinders[i], tMin, tMax));\n  }\n  for (int i = 0; i < sphereCount; ++i) {\n    bestHitInfo = getBetterHitInfo(bestHitInfo, intersectSphere(ray, scene.spheres[i], tMin, tMax));\n  }\n  for (int i = 0; i < planeCount; ++i) {\n    bestHitInfo = getBetterHitInfo(bestHitInfo, intersectPlane(ray, scene.planes[i], tMin, tMax));\n  }\n  \n  return bestHitInfo;\n}\n\nvec3 shadeFromLight(\n  const Scene scene,\n  const Ray ray,\n  const HitInfo hit_info,\n  const PointLight light)\n{ \n  vec3 hitToLight = light.position - hit_info.position;\n  \n  vec3 lightDirection = normalize(hitToLight);\n  vec3 viewDirection = normalize(hit_info.position - ray.origin);\n  vec3 reflectedDirection = reflect(viewDirection, hit_info.normal);\n  float diffuse_term = max(0.0, dot(lightDirection, hit_info.normal));\n  float specular_term  = pow(max(0.0, dot(lightDirection, reflectedDirection)), hit_info.material.glossiness);\n\n#ifdef SOLUTION_SHADOW\n  // Put your shadow test here\n#else\n  \n  float visibility = 1.0;\n#endif\n  \n  return \tvisibility * \n    \t\tlight.color * (\n    \t\tspecular_term * hit_info.material.specular +\n      \t\tdiffuse_term * hit_info.material.diffuse);\n}\n\nvec3 background(const Ray ray) {\n  // A simple implicit sky that can be used for the background\n  return vec3(0.2) + vec3(0.8, 0.6, 0.5) * max(0.0, ray.direction.y);\n}\n\n// It seems to be a WebGL issue that the third parameter needs to be inout instea dof const on Tobias' machine\nvec3 shade(const Scene scene, const Ray ray, inout HitInfo hitInfo) {\n  \n  \tif(!hitInfo.hit) {\n  \t\treturn background(ray);\n  \t}\n  \n    vec3 shading = scene.ambient * hitInfo.material.diffuse;\n    for (int i = 0; i < lightCount; ++i) {\n        shading += shadeFromLight(scene, ray, hitInfo, scene.lights[i]); \n    }\n    return shading;\n}\n\n\nRay getFragCoordRay(const vec2 frag_coord) {\n  \tfloat sensorDistance = 1.0;\n  \tvec2 sensorMin = vec2(-1, -0.5);\n  \tvec2 sensorMax = vec2(1, 0.5);\n  \tvec2 pixelSize = (sensorMax- sensorMin) / vec2(viewport.x, viewport.y);\n  \tvec3 origin = vec3(0, 0, sensorDistance);\n    vec3 direction = normalize(vec3(sensorMin + pixelSize * frag_coord, -sensorDistance));  \n  \n  \treturn Ray(origin, direction);\n}\n\nfloat fresnel(const vec3 viewDirection, const vec3 normal) {\n#ifdef SOLUTION_FRESNEL\n\t// Put your code to compute the Fresnel effect here\n#else\n\treturn 1.0;\n#endif\n}\n\nvec3 colorForFragment(const Scene scene, const vec2 fragCoord) {\n      \n    Ray initialRay = getFragCoordRay(fragCoord);  \n  \tHitInfo initialHitInfo = intersectScene(scene, initialRay, 0.001, 10000.0);  \n  \tvec3 result = shade(scene, initialRay, initialHitInfo);\n\t\n  \tRay currentRay;\n  \tHitInfo currentHitInfo;\n  \t\n  \t// Compute the reflection\n  \tcurrentRay = initialRay;\n  \tcurrentHitInfo = initialHitInfo;\n  \t\n  \t// The initial strength of the reflection\n  \tfloat reflectionWeight = 1.0;\n  \t\n  \tconst int maxReflectionStepCount = 2;\n  \tfor(int i = 0; i < maxReflectionStepCount; i++) {\n      \n      if(!currentHitInfo.hit) break;\n      \n#ifdef SOLUTION_REFLECTION_REFRACTION\n  // Put your reflection weighting code here\n#else\n      \n#endif\n      \n#ifdef SOLUTION_FRESNEL\n#else\n      // Replace with Fresnel code\n      reflectionWeight *= 0.5;\n#endif\n      \n      Ray nextRay;\n#ifdef SOLUTION_REFLECTION_REFRACTION\n\t// Put your code to compute the reflection ray\n#else\n\t\n#endif\n      currentRay = nextRay;\n      \n      currentHitInfo = intersectScene(scene, currentRay, 0.001, 10000.0);      \n            \n      result += reflectionWeight * shade(scene, currentRay, currentHitInfo);\n    }\n  \n  \t// Compute the refraction\n  \tcurrentRay = initialRay;  \n  \tcurrentHitInfo = initialHitInfo;\n   \n  \t// The initial medium is air\n  \tfloat currentIOR = 1.0;\n\n  \t// The initial strength of the refraction.\n  \tfloat refractionWeight = 1.0;\n  \n  \tconst int maxRefractionStepCount = 2;\n  \tfor(int i = 0; i < maxRefractionStepCount; i++) {\n      \n#ifdef SOLUTION_REFLECTION_REFRACTION\n#else\n      // Replace with Fresnel code\n      reflectionWeight *= 0.5;      \n#endif\n\n#ifdef SOLUTION_FRESNEL\n#else\n      // Put Fresnel code here\n#endif      \n\n      Ray nextRay;\n\n\n#ifdef SOLUTION_REFLECTION_REFRACTION      \n\t  //This solution only expects the ray to be in one primitive at a time, and this is expected of student. \n\t  //That is, on exit it'll assume that the ray is in air.\n\t  // Put your code to compute the reflection ray and track the IOR\n#else\n\tfloat sourceIOR;\n\tfloat destIOR;\n\t\n#endif\n      currentHitInfo = intersectScene(scene, currentRay, 0.001, 10000.0);\n            \n      result += refractionWeight * shade(scene, currentRay, currentHitInfo);\n      \n      if(!currentHitInfo.hit) break;\n    }\n  return result;\n}\n\nMaterial getDefaultMaterial() {\n#ifdef SOLUTION_MATERIAL\n#else\n  return Material(vec3(0.3), vec3(0), 1.0);\n#endif\n}\n\nMaterial getPaperMaterial() {\n#ifdef SOLUTION_MATERIAL\n  // Replace by your definition of a paper material\n#else\n  return getDefaultMaterial();\n#endif\n}\n\nMaterial getPlasticMaterial() {\n#ifdef SOLUTION_MATERIAL\n  // Replace by your definition of a plastic material\n#else\n  return getDefaultMaterial();\n#endif\n}\n\nMaterial getGlassMaterial() {\n#ifdef SOLUTION_MATERIAL\n  // Replace by your definition of a glass material\n#else\n  return getDefaultMaterial();\n#endif\n}\n\nMaterial getSteelMirrorMaterial() {\n#ifdef SOLUTION_MATERIAL\n  // Replace by your definition of a steel mirror material\n#else\n  return getDefaultMaterial();\n#endif\n}\n\nvec3 tonemap(const vec3 radiance) {\n  const float monitorGamma = 2.0;\n  return pow(radiance, vec3(1.0 / monitorGamma));\n}\n\nvoid main()\n{\n    // Setup scene\n    Scene scene;\n  \tscene.ambient = vec3(0.12, 0.15, 0.2);\n  \n    // Lights\n    scene.lights[0].position = vec3(5, 15, -5);\n    scene.lights[0].color    = 0.5 * vec3(0.9, 0.5, 0.1);\n    \n  \tscene.lights[1].position = vec3(-15, 5, 2);\n    scene.lights[1].color    = 0.5 * vec3(0.1, 0.3, 1.0);\n  \n    // Primitives\n    scene.spheres[0].position            \t= vec3(10, -5, -16);\n    scene.spheres[0].radius              \t= 6.0;\n    scene.spheres[0].material \t\t\t\t= getPaperMaterial();\n    \n  \tscene.spheres[1].position            \t= vec3(-7, -2, -13);\n    scene.spheres[1].radius             \t= 4.0;\n    scene.spheres[1].material\t\t\t\t= getPlasticMaterial();\n  \n    scene.spheres[2].position            \t= vec3(0, 0.5, -5);\n    scene.spheres[2].radius              \t= 2.0;\n    scene.spheres[2].material   \t\t\t= getGlassMaterial();\n\n  \tscene.planes[0].normal            \t\t= normalize(vec3(0, 0.8, 0));\n  \tscene.planes[0].d              \t\t\t= -4.5;\n    scene.planes[0].material\t\t\t\t= getSteelMirrorMaterial();\n  \n  \tscene.cylinders[0].position            \t= vec3(-1, 1, -26);\n  \tscene.cylinders[0].direction            = normalize(vec3(-2, 2, -1));\n  \tscene.cylinders[0].radius         \t\t= 1.5;\n    scene.cylinders[0].material\t\t\t\t= getPaperMaterial();\n  \n  \tscene.cylinders[1].position            \t= vec3(4, 1, -5);\n  \tscene.cylinders[1].direction            = normalize(vec3(1, 4, 1));\n  \tscene.cylinders[1].radius         \t\t= 0.4;\n    scene.cylinders[1].material\t\t\t\t= getPlasticMaterial();\n\n  // compute color for fragment\n  gl_FragColor.rgb = tonemap(colorForFragment(scene, gl_FragCoord.xy));\n  gl_FragColor.a = 1.0;\n\n}\n`,\n\t\tdescription: ``,\n\t\twrapFunctionStart: ``,\n\t\twrapFunctionEnd: ``\n\t});\n\n\tUI.tabs.push(\n\t\t{\n\t\tvisible: false,\n\t\ttype: `x-shader/x-vertex`,\n\t\ttitle: `RaytracingDemoVS - GL`,\n\t\tid: `RaytracingDemoVS`,\n\t\tinitialValue: `attribute vec3 position;\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n  \n    void main(void) {\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n`,\n\t\tdescription: ``,\n\t\twrapFunctionStart: ``,\n\t\twrapFunctionEnd: ``\n\t});\n\n\t return UI; \n}//!setup\n\nvar gl;\nfunction initGL(canvas) {\n\ttry {\n\t\tgl = canvas.getContext(\"experimental-webgl\");\n\t\tgl.viewportWidth = canvas.width;\n\t\tgl.viewportHeight = canvas.height;\n\t} catch (e) {\n\t}\n\tif (!gl) {\n\t\talert(\"Could not initialise WebGL, sorry :-(\");\n\t}\n}\n\nfunction getShader(gl, id) {\n\tvar shaderScript = document.getElementById(id);\n\tif (!shaderScript) {\n\t\treturn null;\n\t}\n\n\tvar str = \"\";\n\tvar k = shaderScript.firstChild;\n\twhile (k) {\n\t\tif (k.nodeType == 3) {\n\t\t\tstr += k.textContent;\n\t\t}\n\t\tk = k.nextSibling;\n\t}\n\n\tvar shader;\n\tif (shaderScript.type == \"x-shader/x-fragment\") {\n\t\tshader = gl.createShader(gl.FRAGMENT_SHADER);\n\t} else if (shaderScript.type == \"x-shader/x-vertex\") {\n\t\tshader = gl.createShader(gl.VERTEX_SHADER);\n\t} else {\n\t\treturn null;\n\t}\n\n    console.log(str);\n\tgl.shaderSource(shader, str);\n\tgl.compileShader(shader);\n\n\tif (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n\t\talert(gl.getShaderInfoLog(shader));\n\t\treturn null;\n\t}\n\n\treturn shader;\n}\n\nfunction RaytracingDemo() {\n}\n\nRaytracingDemo.prototype.initShaders = function() {\n\n\tthis.shaderProgram = gl.createProgram();\n\n\tgl.attachShader(this.shaderProgram, getShader(gl, \"RaytracingDemoVS\"));\n\tgl.attachShader(this.shaderProgram, getShader(gl, \"RaytracingDemoFS\"));\n\tgl.linkProgram(this.shaderProgram);\n\n\tif (!gl.getProgramParameter(this.shaderProgram, gl.LINK_STATUS)) {\n\t\talert(\"Could not initialise shaders\");\n\t}\n\n\tgl.useProgram(this.shaderProgram);\n\n\tthis.shaderProgram.vertexPositionAttribute = gl.getAttribLocation(this.shaderProgram, \"position\");\n\tgl.enableVertexAttribArray(this.shaderProgram.vertexPositionAttribute);\n\n\tthis.shaderProgram.projectionMatrixUniform = gl.getUniformLocation(this.shaderProgram, \"projectionMatrix\");\n\tthis.shaderProgram.modelviewMatrixUniform = gl.getUniformLocation(this.shaderProgram, \"modelViewMatrix\");\n}\n\nRaytracingDemo.prototype.initBuffers = function() {\n\tthis.triangleVertexPositionBuffer = gl.createBuffer();\n\tgl.bindBuffer(gl.ARRAY_BUFFER, this.triangleVertexPositionBuffer);\n\t\n\tvar vertices = [\n\t\t -1,  -1,  0,\n\t\t -1,  1,  0,\n\t\t 1,  1,  0,\n\n\t\t -1,  -1,  0,\n\t\t 1,  -1,  0,\n\t\t 1,  1,  0,\n\t ];\n\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n\tthis.triangleVertexPositionBuffer.itemSize = 3;\n\tthis.triangleVertexPositionBuffer.numItems = 3 * 2;\n}\n\nRaytracingDemo.prototype.drawScene = function() {\n\t\t\t\n\tvar perspectiveMatrix = new J3DIMatrix4();\t\n\tperspectiveMatrix.setUniform(gl, this.shaderProgram.projectionMatrixUniform, false);\n\n\tvar modelViewMatrix = new J3DIMatrix4();\t\n\tmodelViewMatrix.setUniform(gl, this.shaderProgram.modelviewMatrixUniform, false);\n\t\t\n\tgl.bindBuffer(gl.ARRAY_BUFFER, this.triangleVertexPositionBuffer);\n\tgl.vertexAttribPointer(this.shaderProgram.vertexPositionAttribute, this.triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\t\n\tgl.uniform2iv(gl.getUniformLocation(this.shaderProgram, \"viewport\"), [getRenderTargetWidth(), getRenderTargetHeight()]);\n\t\n\tgl.drawArrays(gl.TRIANGLES, 0, this.triangleVertexPositionBuffer.numItems);\n}\n\nRaytracingDemo.prototype.run = function() {\n\tthis.initShaders();\n\tthis.initBuffers();\n\n\tgl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);\n\tgl.clear(gl.COLOR_BUFFER_BIT);\n\n\tthis.drawScene();\n};\n\nfunction init() {\t\n\t\n\n\tenv = new RaytracingDemo();\t\n\tenv.run();\n\n    return env;\n}\n\nfunction compute(canvas)\n{\n    env.initShaders();\n    env.initBuffers();\n\n    gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    env.drawScene();\n}\n\n", "function setup()\n{\n\tUI = {};\n\tUI.tabs = [];\n\tUI.titleLong = 'Rasterization Demo';\n\tUI.titleShort = 'rasterizationDemo';\n\tUI.numFrames = 1000;\n\tUI.maxFPS = 24;\n\tUI.renderWidth = 800;\n\tUI.renderHeight = 400;\n\n\tUI.tabs.push(\n\t\t{\n\t\tvisible: true,\n\t\ttype: `x-shader/x-fragment`,\n\t\ttitle: `Rasterization`,\n\t\tid: `RasterizationDemoFS`,\n\t\tinitialValue: `//#define PROJECTION\n//#define RASTERIZATION\n//#define CLIPPING\n//#define INTERPOLATION\n//#define ZBUFFERING\n\nprecision highp float;\nuniform float time;\n\n// Polygon / vertex functionality\nconst int MAX_VERTEX_COUNT = 8;\n\nuniform ivec2 viewport;\n\nstruct Vertex {\n    vec4 position;\n    vec3 color;\n};\n\nstruct Polygon {\n    // Numbers of vertices, i.e., points in the polygon\n    int vertexCount;\n    // The vertices themselves\n    Vertex vertices[MAX_VERTEX_COUNT];\n};\n\n// Appends a vertex to a polygon\nvoid appendVertexToPolygon(inout Polygon polygon, Vertex element) {\n    for (int i = 0; i < MAX_VERTEX_COUNT; ++i) {\n        if (i == polygon.vertexCount) {\n            polygon.vertices[i] = element;\n        }\n    }\n    polygon.vertexCount++;\n}\n\n// Copy Polygon source to Polygon destination\nvoid copyPolygon(inout Polygon destination, Polygon source) {\n    for (int i = 0; i < MAX_VERTEX_COUNT; ++i) {\n        destination.vertices[i] = source.vertices[i];\n    }\n    destination.vertexCount = source.vertexCount;\n}\n\n// Get the i-th vertex from a polygon, but when asking for the one behind the last, get the first again\nVertex getWrappedPolygonVertex(Polygon polygon, int index) {\n    if (index >= polygon.vertexCount) index -= polygon.vertexCount;\n    for (int i = 0; i < MAX_VERTEX_COUNT; ++i) {\n        if (i == index) return polygon.vertices[i];\n    }\n}\n\n// Creates an empty polygon\nvoid makeEmptyPolygon(out Polygon polygon) {\n  polygon.vertexCount = 0;\n}\n\n// Clipping part\n\n#define ENTERING 0\n#define LEAVING 1\n#define OUTSIDE 2\n#define INSIDE 3\n\nint getCrossType(Vertex poli1, Vertex poli2, Vertex wind1, Vertex wind2) {\n#ifdef CLIPPING\n    // TODO\n#else\n    return INSIDE;\n#endif\n}\n\n// This function assumes that the segments are not parallel or collinear.\nVertex intersect2D(Vertex a, Vertex b, Vertex c, Vertex d) {\n#ifdef CLIPPING\n    // TODO\n#else\n    return a;\n#endif\n}\n\nvoid sutherlandHodgmanClip(Polygon unclipped, Polygon clipWindow, out Polygon result) {\n    Polygon clipped;\n    copyPolygon(clipped, unclipped);\n\n    // Loop over the clip window\n    for (int i = 0; i < MAX_VERTEX_COUNT; ++i) {\n        if (i >= clipWindow.vertexCount) break;\n\n        // Make a temporary copy of the current clipped polygon\n        Polygon oldClipped;\n        copyPolygon(oldClipped, clipped);\n\n        // Set the clipped polygon to be empty\n        makeEmptyPolygon(clipped);\n\n        // Loop over the current clipped polygon\n        for (int j = 0; j < MAX_VERTEX_COUNT; ++j) {\n            if (j >= oldClipped.vertexCount) break;\n            \n            // Handle the j-th vertex of the clipped polygon. This should make use of the function \n            // intersect() to be implemented above.\n#ifdef CLIPPING\n            // TODO\n#else\n            appendVertexToPolygon(clipped, getWrappedPolygonVertex(oldClipped, j));\n#endif\n        }\n    }\n\n    // Copy the last version to the output\n    copyPolygon(result, clipped);\n}\n\n// Rasterization and culling part\n\n#define INNER_SIDE 0\n#define OUTER_SIDE 1\n\n// Assuming a clockwise (vertex-wise) polygon, returns whether the input point \n// is on the inner or outer side of the edge (ab)\nint edge(vec2 point, Vertex a, Vertex b) {\n#ifdef RASTERIZATION\n    // TODO\n#endif\n    return OUTER_SIDE;\n}\n\n// Returns if a point is inside a polygon or not\nbool isPointInPolygon(vec2 point, Polygon polygon) {\n    // Don't evaluate empty polygons\n    if (polygon.vertexCount == 0) return false;\n    // Check against each edge of the polygon\n    bool rasterise = true;\n    for (int i = 0; i < MAX_VERTEX_COUNT; ++i) {\n        if (i < polygon.vertexCount) {\n#ifdef RASTERIZATION\n            // TODO\n#else\n            rasterise = false;\n#endif\n        }\n    }\n    return rasterise;\n}\n\nbool isPointOnPolygonVertex(vec2 point, Polygon polygon) {\n    for (int i = 0; i < MAX_VERTEX_COUNT; ++i) {\n        if (i < polygon.vertexCount) {\n          \tivec2 pixelDifference = ivec2(abs(polygon.vertices[i].position.xy - point) * vec2(viewport));\n          \tint pointSize = viewport.x / 200;\n            if( pixelDifference.x <= pointSize && pixelDifference.y <= pointSize) {\n              return true;\n            }\n        }\n    }\n    return false;\n}\n\nfloat triangleArea(vec2 a, vec2 b, vec2 c) {\n    // https://en.wikipedia.org/wiki/Heron%27s_formula\n    float ab = length(a - b);\n    float bc = length(b - c);\n    float ca = length(c - a);\n    float s = (ab + bc + ca) / 2.0;\n    return sqrt(max(0.0, s * (s - ab) * (s - bc) * (s - ca)));\n}\n\nVertex interpolateVertex(vec2 point, Polygon polygon) {\n    vec3 colorSum = vec3(0.0);\n    vec4 positionSum = vec4(0.0);\n    float weight_sum = 0.0;\n\tfloat weight_corr_sum = 0.0;\n    \n\tfor (int i = 0; i < MAX_VERTEX_COUNT; ++i) {\n        if (i < polygon.vertexCount) {\n#if defined(INTERPOLATION) || defined(ZBUFFERING)\n            // TODO\n#endif\n\n#ifdef ZBUFFERING\n            // TODO\n#endif\n\n#ifdef INTERPOLATION\n            // TODO\n#endif\n        }\n    }\n    Vertex result = polygon.vertices[0];\n  \n#ifdef INTERPOLATION\n    // TODO\n#endif\n#ifdef ZBUFFERING\n    // TODO\n#endif\n\n  return result;\n}\n\n// Projection part\n\n// Used to generate a projection matrix.\nmat4 computeProjectionMatrix() {\n    mat4 projectionMatrix = mat4(1);\n  \n  float aspect = float(viewport.x) / float(viewport.y);  \n  float imageDistance = 2.0;\n\n#ifdef PROJECTION\n    // TODO\n#endif\n  \n    return projectionMatrix;\n}\n\n// Used to generate a simple \"look-at\" camera. \nmat4 computeViewMatrix(vec3 VRP, vec3 TP, vec3 VUV) {\n    mat4 viewMatrix = mat4(1);\n\n#ifdef PROJECTION\n    // TODO\n#endif\n    return viewMatrix;\n}\n\nvec3 getCameraPosition() {  \n    //return 10.0 * vec3(sin(time * 1.3), 0, cos(time * 1.3));\n\treturn 10.0 * vec3(sin(0.0), 0, cos(0.0));\n}\n\n// Takes a single input vertex and projects it using the input view and projection matrices\nvec4 projectVertexPosition(vec4 position) {\n\n  // Set the parameters for the look-at camera.\n    vec3 TP = vec3(0, 0, 0);\n  \tvec3 VRP = getCameraPosition();\n    vec3 VUV = vec3(0, 1, 0);\n  \n    // Compute the view matrix.\n    mat4 viewMatrix = computeViewMatrix(VRP, TP, VUV);\n\n  // Compute the projection matrix.\n    mat4 projectionMatrix = computeProjectionMatrix();\n  \n#ifdef PROJECTION\n    // TODO\n#else\n    return position;\n#endif\n}\n\n// Projects all the vertices of a polygon\nvoid projectPolygon(inout Polygon projectedPolygon, Polygon polygon) {\n    copyPolygon(projectedPolygon, polygon);\n    for (int i = 0; i < MAX_VERTEX_COUNT; ++i) {\n        if (i < polygon.vertexCount) {\n            projectedPolygon.vertices[i].position = projectVertexPosition(polygon.vertices[i].position);\n        }\n    }\n}\n\n// Draws a polygon by projecting, clipping, ratserizing and interpolating it\nvoid drawPolygon(\n  vec2 point, \n  Polygon clipWindow, \n  Polygon oldPolygon, \n  inout vec3 color, \n  inout float depth)\n{\n    Polygon projectedPolygon;\n    projectPolygon(projectedPolygon, oldPolygon);  \n  \n    Polygon clippedPolygon;\n    sutherlandHodgmanClip(projectedPolygon, clipWindow, clippedPolygon);\n\n    if (isPointInPolygon(point, clippedPolygon)) {\n      \n        Vertex interpolatedVertex = \n          interpolateVertex(point, projectedPolygon);\n#if defined(ZBUFFERING)\n        // TODO: Put your code to handle z buffering here\n#else\n      color = interpolatedVertex.color;\n      depth = interpolatedVertex.position.z;      \n#endif\n   }\n  \n   if (isPointOnPolygonVertex(point, clippedPolygon)) {\n        color = vec3(1);\n   }\n}\n\n// Main function calls\n\nvoid drawScene(vec2 pixelCoord, inout vec3 color) {\n    color = vec3(0.3, 0.3, 0.3);\n  \n  \t// Convert from GL pixel coordinates 0..N-1 to our screen coordinates -1..1\n    vec2 point = 2.0 * pixelCoord / vec2(viewport) - vec2(1.0);\n\n    Polygon clipWindow;\n    clipWindow.vertices[0].position = vec4(-0.65,  0.95, 1.0, 1.0);\n    clipWindow.vertices[1].position = vec4( 0.65,  0.75, 1.0, 1.0);\n    clipWindow.vertices[2].position = vec4( 0.75, -0.65, 1.0, 1.0);\n    clipWindow.vertices[3].position = vec4(-0.75, -0.85, 1.0, 1.0);\n    clipWindow.vertexCount = 4;\n  \n  \t// Draw the area outside the clip region to be dark\n    color = isPointInPolygon(point, clipWindow) ? vec3(0.5) : color;\n\n    const int triangleCount = 2;\n    Polygon triangles[triangleCount];\n  \n    triangles[0].vertices[0].position = vec4(-3, -2, 0.0, 1.0);\n    triangles[0].vertices[1].position = vec4(4, 0, 3.0, 1.0);\n    triangles[0].vertices[2].position = vec4(-1, 2, 0.0, 1.0);\n    triangles[0].vertices[0].color = vec3(1.0, 1.0, 0.2);\n    triangles[0].vertices[1].color = vec3(0.8, 0.8, 0.8);\n    triangles[0].vertices[2].color = vec3(0.5, 0.2, 0.5);\n    triangles[0].vertexCount = 3;\n  \n    triangles[1].vertices[0].position = vec4(3.0, 2.0, -2.0, 1.0);\n  \ttriangles[1].vertices[2].position = vec4(0.0, -2.0, 3.0, 1.0);\n    triangles[1].vertices[1].position = vec4(-1.0, 2.0, 4.0, 1.0);\n    triangles[1].vertices[1].color = vec3(0.2, 1.0, 0.1);\n    triangles[1].vertices[2].color = vec3(1.0, 1.0, 1.0);\n    triangles[1].vertices[0].color = vec3(0.1, 0.2, 1.0);\n    triangles[1].vertexCount = 3;\n\t\n    float depth = 10000.0;\n    // Project and draw all the triangles\n    for (int i = 0; i < triangleCount; i++) {\n        drawPolygon(point, clipWindow, triangles[i], color, depth);\n    }   \n}\n\nvoid main() {\n    drawScene(gl_FragCoord.xy, gl_FragColor.rgb);\n    gl_FragColor.a = 1.0;\n}`,\n\t\tdescription: ``,\n\t\twrapFunctionStart: ``,\n\t\twrapFunctionEnd: ``\n\t});\n\n\tUI.tabs.push(\n\t\t{\n\t\tvisible: false,\n\t\ttype: `x-shader/x-vertex`,\n\t\ttitle: `RasterizationDemoTextureVS - GL`,\n\t\tid: `RasterizationDemoTextureVS`,\n\t\tinitialValue: `attribute vec3 position;\n    attribute vec2 textureCoord;\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    varying highp vec2 vTextureCoord;\n  \n    void main(void) {\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        vTextureCoord = textureCoord;\n    }\n`,\n\t\tdescription: ``,\n\t\twrapFunctionStart: ``,\n\t\twrapFunctionEnd: ``\n\t});\n\n\tUI.tabs.push(\n\t\t{\n\t\tvisible: false,\n\t\ttype: `x-shader/x-vertex`,\n\t\ttitle: `RasterizationDemoVS - GL`,\n\t\tid: `RasterizationDemoVS`,\n\t\tinitialValue: `attribute vec3 position;\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    void main(void) {\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n`,\n\t\tdescription: ``,\n\t\twrapFunctionStart: ``,\n\t\twrapFunctionEnd: ``\n\t});\n\n\tUI.tabs.push(\n\t\t{\n\t\tvisible: false,\n\t\ttype: `x-shader/x-fragment`,\n\t\ttitle: `RasterizationDemoTextureFS - GL`,\n\t\tid: `RasterizationDemoTextureFS`,\n\t\tinitialValue: `\n        varying highp vec2 vTextureCoord;\n\n        uniform sampler2D uSampler;\n\n        void main(void) {\n            gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));\n        }\n`,\n\t\tdescription: ``,\n\t\twrapFunctionStart: ``,\n\t\twrapFunctionEnd: ``\n\t});\n\n\t return UI; \n}//!setup\n\nvar gl;\nfunction initGL(canvas) {\n    try {\n        gl = canvas.getContext(\"webgl\");\n        gl.viewportWidth = canvas.width;\n        gl.viewportHeight = canvas.height;\n    } catch (e) {\n    }\n    if (!gl) {\n        alert(\"Could not initialise WebGL, sorry :-(\");\n    }\n}\n\nfunction evalJS(id) {\n    var jsScript = document.getElementById(id);\n    eval(jsScript.innerHTML);\n}\n\nfunction getShader(gl, id) {\n    var shaderScript = document.getElementById(id);\n    if (!shaderScript) {\n        return null;\n    }\n\n    var str = \"\";\n    var k = shaderScript.firstChild;\n    while (k) {\n        if (k.nodeType == 3) {\n            str += k.textContent;\n        }\n        k = k.nextSibling;\n    }\n\n    var shader;\n    if (shaderScript.type == \"x-shader/x-fragment\") {\n        shader = gl.createShader(gl.FRAGMENT_SHADER);\n    } else if (shaderScript.type == \"x-shader/x-vertex\") {\n        shader = gl.createShader(gl.VERTEX_SHADER);\n    } else {\n        return null;\n    }\n\n    gl.shaderSource(shader, str);\n    gl.compileShader(shader);\n\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        alert(gl.getShaderInfoLog(shader));\n        return null;\n    }\n\n    return shader;\n}\n\nfunction RasterizationDemo() {\n}\n\nRasterizationDemo.prototype.initShaders = function() {\n\n    this.shaderProgram = gl.createProgram();\n\n    gl.attachShader(this.shaderProgram, getShader(gl, \"RasterizationDemoVS\"));\n    gl.attachShader(this.shaderProgram, getShader(gl, \"RasterizationDemoFS\"));\n    gl.linkProgram(this.shaderProgram);\n\n    if (!gl.getProgramParameter(this.shaderProgram, gl.LINK_STATUS)) {\n        alert(\"Could not initialise shaders\");\n    }\n\n    gl.useProgram(this.shaderProgram);\n\n    this.shaderProgram.vertexPositionAttribute = gl.getAttribLocation(this.shaderProgram, \"position\");\n    gl.enableVertexAttribArray(this.shaderProgram.vertexPositionAttribute);\n\n    this.shaderProgram.projectionMatrixUniform = gl.getUniformLocation(this.shaderProgram, \"projectionMatrix\");\n    this.shaderProgram.modelviewMatrixUniform = gl.getUniformLocation(this.shaderProgram, \"modelViewMatrix\");\n}\n\nRasterizationDemo.prototype.initTextureShaders = function() {\n\n    this.textureShaderProgram = gl.createProgram();\n\n    gl.attachShader(this.textureShaderProgram, getShader(gl, \"RasterizationDemoTextureVS\"));\n    gl.attachShader(this.textureShaderProgram, getShader(gl, \"RasterizationDemoTextureFS\"));\n    gl.linkProgram(this.textureShaderProgram);\n\n    if (!gl.getProgramParameter(this.textureShaderProgram, gl.LINK_STATUS)) {\n        alert(\"Could not initialise shaders\");\n    }\n\n    gl.useProgram(this.textureShaderProgram);\n\n    this.textureShaderProgram.vertexPositionAttribute = gl.getAttribLocation(this.textureShaderProgram, \"position\");\n    gl.enableVertexAttribArray(this.textureShaderProgram.vertexPositionAttribute);\n\n    this.textureShaderProgram.textureCoordAttribute = gl.getAttribLocation(this.textureShaderProgram, \"textureCoord\");\n    gl.enableVertexAttribArray(this.textureShaderProgram.textureCoordAttribute);\n    //gl.vertexAttribPointer(this.textureShaderProgram.textureCoordAttribute, 2, gl.FLOAT, false, 0, 0);\n\n    this.textureShaderProgram.projectionMatrixUniform = gl.getUniformLocation(this.textureShaderProgram, \"projectionMatrix\");\n    this.textureShaderProgram.modelviewMatrixUniform = gl.getUniformLocation(this.textureShaderProgram, \"modelViewMatrix\");\n}\n\nRasterizationDemo.prototype.initBuffers = function() {\n    this.triangleVertexPositionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.triangleVertexPositionBuffer);\n    \n    var vertices = [\n         -1.0,  -1.0,  0.0,\n         -1.0,   1.0,  0.0,\n          1.0,   1.0,  0.0,\n\n         -1.0,  -1.0,  0.0,\n          1.0,  -1.0,  0.0,\n          1.0,   1.0,  0.0,\n     ];\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n    this.triangleVertexPositionBuffer.itemSize = 3;\n    this.triangleVertexPositionBuffer.numItems = 3 * 2;\n\n    this.textureCoordBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.textureCoordBuffer);\n\n    var textureCoords = [\n        0.0,  0.0,\n        0.0,  1.0,\n        1.0,  1.0,\n\n        0.0,  0.0,\n        1.0,  0.0,\n        1.0,  1.0\n    ];\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);\n    this.textureCoordBuffer.itemSize = 2;\n}\n\nfunction getTime() {  \n\tvar d = new Date();\n\treturn d.getMinutes() * 60.0 + d.getSeconds() + d.getMilliseconds() / 1000.0;\n}\n\n\nRasterizationDemo.prototype.initTextureFramebuffer = function() {\n    // create off-screen framebuffer\n    this.framebuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);\n    this.framebuffer.width = this.prerender_width;\n    this.framebuffer.height = this.prerender_height;\n\n    // create RGB texture\n    this.framebufferTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, this.framebufferTexture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.framebuffer.width, this.framebuffer.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);//LINEAR_MIPMAP_NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    //gl.generateMipmap(gl.TEXTURE_2D);\n\n    // create depth buffer\n    this.renderbuffer = gl.createRenderbuffer();\n    gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderbuffer);\n    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.framebuffer.width, this.framebuffer.height);\n\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.framebufferTexture, 0);\n    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.renderbuffer);\n\n    // reset state\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n}\n\nRasterizationDemo.prototype.drawScene = function() {\n            \n    gl.bindFramebuffer(gl.FRAMEBUFFER, env.framebuffer);\n    gl.useProgram(this.shaderProgram);\n    gl.viewport(0, 0, this.prerender_width, this.prerender_height);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n        var perspectiveMatrix = new J3DIMatrix4();  \n        perspectiveMatrix.setUniform(gl, this.shaderProgram.projectionMatrixUniform, false);\n\n        var modelViewMatrix = new J3DIMatrix4();    \n        modelViewMatrix.setUniform(gl, this.shaderProgram.modelviewMatrixUniform, false);\n\n        gl.uniform2iv(gl.getUniformLocation(this.shaderProgram, \"viewport\"), [getRenderTargetWidth(), getRenderTargetHeight()]);\n            \n\t\tgl.uniform1f(gl.getUniformLocation(this.shaderProgram, \"time\"), getTime());  \n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.triangleVertexPositionBuffer);\n        gl.vertexAttribPointer(this.shaderProgram.vertexPositionAttribute, this.triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.textureCoordBuffer);\n        gl.vertexAttribPointer(this.textureShaderProgram.textureCoordAttribute, this.textureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);\n        \n        gl.drawArrays(gl.TRIANGLES, 0, this.triangleVertexPositionBuffer.numItems);\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.useProgram(this.textureShaderProgram);\n    gl.viewport(0, 0, this.render_width, this.render_height);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n        var perspectiveMatrix = new J3DIMatrix4();  \n        perspectiveMatrix.setUniform(gl, this.textureShaderProgram.projectionMatrixUniform, false);\n\n        var modelViewMatrix = new J3DIMatrix4();    \n        modelViewMatrix.setUniform(gl, this.textureShaderProgram.modelviewMatrixUniform, false);\n\n        gl.bindTexture(gl.TEXTURE_2D, this.framebufferTexture);\n        gl.uniform1i(gl.getUniformLocation(this.textureShaderProgram, \"uSampler\"), 0);\n            \n        gl.bindBuffer(gl.ARRAY_BUFFER, this.triangleVertexPositionBuffer);\n        gl.vertexAttribPointer(this.textureShaderProgram.vertexPositionAttribute, this.triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.textureCoordBuffer);\n        gl.vertexAttribPointer(this.textureShaderProgram.textureCoordAttribute, this.textureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);\n        \n        gl.drawArrays(gl.TRIANGLES, 0, this.triangleVertexPositionBuffer.numItems);\n}\n\nRasterizationDemo.prototype.run = function() {\n\n    this.render_width     = 800;\n    this.render_height    = 400;\n\n    this.prerender_width  = this.render_width;\n    this.prerender_height = this.render_height;\n\n    this.initTextureFramebuffer();\n    this.initShaders();\n    this.initTextureShaders();\n    this.initBuffers();\n};\n\nfunction init() {   \n    env = new RasterizationDemo();\n\n    return env;\n}\n\nfunction compute(canvas)\n{\n    env.run();\n    env.drawScene();\n}\n\n", "function setup()\n{\n\tUI = {};\n\tUI.tabs = [];\n\tUI.titleLong = 'Path Tracer';\n\tUI.titleShort = 'PathTracer';\n\tUI.numFrames = 100000;\n\tUI.maxFPS = 1000;\n\tUI.renderWidth = 512;\n\tUI.renderHeight = 256;\n\n\tUI.tabs.push(\n\t\t{\n\t\tvisible: true,\n\t\ttype: `x-shader/x-fragment`,\n\t\ttitle: `Raytracing`,\n\t\tid: `TraceFS`,\n\t\tinitialValue: `//#define SOLUTION_LIGHT\n//#define SOLUTION_BOUNCE\n//#define SOLUTION_THROUGHPUT\n//#define SOLUTION_HALTON\n//#define SOLUTION_NEXT_EVENT_ESTIMATION\n//#define SOLUTION_AA\n\nprecision highp float;\n\n#define M_PI 3.1415\n\nstruct Material {\n#ifdef SOLUTION_LIGHT    \n#endif  \n  vec3 diffuse;\n  vec3 specular;\n  float glossiness;\n};\n\nstruct Sphere {\n  vec3 position;\n  float radius;\n  Material material;\n};\n\nstruct Plane {\n  vec3 normal;\n  float d;\n  Material material;\n};\n\nconst int sphereCount = 4;\nconst int planeCount = 4;\nconst int emittingSphereCount = 2;\n#ifdef SOLUTION_BOUNCE\n#else\nconst int maxPathLength = 1;\n#endif\n\nstruct Scene {\n  Sphere[sphereCount] spheres;\n  Plane[planeCount] planes;\n};\n\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\n\n// Contains all information pertaining to a ray/object intersection\nstruct HitInfo {\n  bool hit;\n  float t;\n  vec3 position;\n  vec3 normal;\n  Material material;\n};\n\nHitInfo getEmptyHit() {\n  Material emptyMaterial;\n#ifdef SOLUTION_LIGHT  \n#endif  \n  emptyMaterial.diffuse = vec3(0.0);\n  emptyMaterial.specular = vec3(0.0);\n  emptyMaterial.glossiness = 0.0;\n  return HitInfo(false, 0.0, vec3(0.0), vec3(0.0), emptyMaterial);\n}\n\n// Sorts the two t values such that t1 is smaller than t2\nvoid sortT(inout float t1, inout float t2) {\n  // Make t1 the smaller t\n  if(t2 < t1)  {\n    float temp = t1;\n    t1 = t2;\n    t2 = temp;\n  }\n}\n\n// Tests if t is in an interval\nbool isTInInterval(const float t, const float tMin, const float tMax) {\n  return t > tMin && t < tMax;\n}\n\n// Get the smallest t in an interval\nbool getSmallestTInInterval(float t0, float t1, const float tMin, const float tMax, inout float smallestTInInterval) {\n  \n  sortT(t0, t1);\n  \n  // As t0 is smaller, test this first\n  if(isTInInterval(t0, tMin, tMax)) {\n  \tsmallestTInInterval = t0;\n    return true;\n  }\n  \n  // If t0 was not in the interval, still t1 could be\n  if(isTInInterval(t1, tMin, tMax)) {\n  \tsmallestTInInterval = t1;\n    return true;\n  }  \n  \n  // None was\n  return false;\n}\n\nHitInfo intersectSphere(const Ray ray, const Sphere sphere, const float tMin, const float tMax) {\n              \n    vec3 to_sphere = ray.origin - sphere.position;\n  \n    float a = dot(ray.direction, ray.direction);\n    float b = 2.0 * dot(ray.direction, to_sphere);\n    float c = dot(to_sphere, to_sphere) - sphere.radius * sphere.radius;\n    float D = b * b - 4.0 * a * c;\n    if (D > 0.0)\n    {\n\t\tfloat t0 = (-b - sqrt(D)) / (2.0 * a);\n\t\tfloat t1 = (-b + sqrt(D)) / (2.0 * a);\n      \n      \tfloat smallestTInInterval;\n      \tif(!getSmallestTInInterval(t0, t1, tMin, tMax, smallestTInInterval)) {\n          return getEmptyHit();\n        }\n      \n      \tvec3 hitPosition = ray.origin + smallestTInInterval * ray.direction;      \n\n      \tvec3 normal = \n          \tlength(ray.origin - sphere.position) < sphere.radius + 0.001? \n          \t-normalize(hitPosition - sphere.position) : \n      \t\tnormalize(hitPosition - sphere.position);      \n\n        return HitInfo(\n          \ttrue,\n          \tsmallestTInInterval,\n          \thitPosition,\n          \tnormal,\n          \tsphere.material);\n    }\n    return getEmptyHit();\n}\n\nHitInfo intersectPlane(Ray ray, Plane plane) {\n  float t = -(dot(ray.origin, plane.normal) + plane.d) / dot(ray.direction, plane.normal);\n  vec3 hitPosition = ray.origin + t * ray.direction;\n  return HitInfo(\n\ttrue,\n\tt,\n\thitPosition,\n\tnormalize(plane.normal),\n\tplane.material); \n    return getEmptyHit();\n}\n\nfloat lengthSquared(const vec3 x) {\n  return dot(x, x);\n}\n\nHitInfo intersectScene(Scene scene, Ray ray, const float tMin, const float tMax)\n{\n    HitInfo best_hit_info;\n    best_hit_info.t = tMax;\n  \tbest_hit_info.hit = false;\n\n    for (int i = 0; i < sphereCount; ++i) {\n        Sphere sphere = scene.spheres[i];\n        HitInfo hit_info = intersectSphere(ray, sphere, tMin, tMax);\n\n        if(\thit_info.hit && \n           \thit_info.t < best_hit_info.t &&\n           \thit_info.t > tMin)\n        {\n            best_hit_info = hit_info;\n        }\n    }\n\n    for (int i = 0; i < planeCount; ++i) {\n        Plane plane = scene.planes[i];\n        HitInfo hit_info = intersectPlane(ray, plane);\n\n        if(\thit_info.hit && \n           \thit_info.t < best_hit_info.t &&\n           \thit_info.t > tMin)\n        {\n            best_hit_info = hit_info;\n        }\n    }\n  \n  return best_hit_info;\n}\n\n// Converts a random integer in 15 bits to a float in (0, 1)\nfloat randomInetegerToRandomFloat(int i) {\n\treturn float(i) / 32768.0;\n}\n\n// Returns a random integer for every pixel and dimension that remains the same in all iterations\nint pixelIntegerSeed(const int dimensionIndex) {\n  vec3 p = vec3(gl_FragCoord.xy, dimensionIndex);\n  vec3 r = vec3(23.14069263277926, 2.665144142690225,7.358926345 );\n  return int(32768.0 * fract(cos(dot(p,r)) * 123456.0));  \n}\n\n// Returns a random float for every pixel that remains the same in all iterations\nfloat pixelSeed(const int dimensionIndex) {\n  \treturn randomInetegerToRandomFloat(pixelIntegerSeed(dimensionIndex));\n}\n\n// The global random seed of this iteration\n// It will be set to a new random value in each step\nuniform int globalSeed;\nint randomSeed;\nvoid initRandomSequence() {\n  randomSeed = globalSeed + pixelIntegerSeed(0);\n}\n\n// Computesinteger  x modulo y not available in most WEBGL SL implementations\nint mod(const int x, const int y) {\n  return int(float(x) - floor(float(x) / float(y)) * float(y));\n}\n\n// Returns the next integer in a pseudo-random sequence\nint rand() {\n  \trandomSeed = randomSeed * 1103515245 + 12345;   \n\treturn mod(randomSeed / 65536, 32768);\n}\n\n// Returns the next float in this pixels pseudo-random sequence\nfloat uniformRandom() {\n\treturn randomInetegerToRandomFloat(rand());\n}\n\n// Returns the ith prime number for the first 20 \nconst int maxDimensionCount = 10;\nint prime(const int index) {\n  if(index == 0) return 2;\n  if(index == 1) return 3;\n  if(index == 2) return 5;\n  if(index == 3) return 7;\n  if(index == 4) return 11;\n  if(index == 5) return 13;\n  if(index == 6) return 17;\n  if(index == 7) return 19;\n  if(index == 8) return 23;\n  if(index == 9) return 29;\n  if(index == 10) return 31;\n  if(index == 11) return 37;\n  if(index == 12) return 41;\n  if(index == 13) return 43;\n  if(index == 14) return 47;\n  if(index == 15) return 53;\n  return 2;\n}\n\n#ifdef SOLUTION_HALTON\n#endif\n\nfloat halton(const int sampleIndex, const int dimensionIndex) {\n#ifdef SOLUTION_HALTON  \n#else\n  // Put your imeplemntation of halton here\n  return 0.0;\n  #endif\n}\n\n// This is the index of the sample controlled by the framework.\n// It increments by one in every call of this shader\nuniform int baseSampleIndex;\n\n// Returns a well-distributed number in (0,1) for the dimension dimensionIndex\nfloat sample(const int dimensionIndex) {\n#ifdef SOLUTION_HALTON  \n#else\n  // Replace the line below to use the Halton sequence for variance reduction\n  return uniformRandom();\n#endif  \n}\n\n// This is a helper function to sample two-dimensionaly in dimension dimensionIndex\nvec2 sample2(const int dimensionIndex) {\n  return vec2(sample(dimensionIndex + 0), sample(dimensionIndex + 1));\n}\n\nvec3 sample3(const int dimensionIndex) {\n  return vec3(sample(dimensionIndex + 0), sample(dimensionIndex + 1), sample(dimensionIndex + 2));\n}\n\n// This is a register of all dimensions that we will want to sample.\n// Thanks to Iliyan Georgiev from Solid Angle for explaining proper housekeeping of sample dimensions in ranomdized Quasi-Monte Carlo\n//\n// So if we want to use lens sampling, we call sample(LENS_SAMPLE_DIMENSION).\n//\n// There are infinitely many path sampling dimensions.\n// These start at PATH_SAMPLE_DIMENSION.\n// The 2D sample pair for vertex i is at PATH_SAMPLE_DIMENSION + PATH_SAMPLE_DIMENSION_MULTIPLIER * i + 0\n#define ANTI_ALIAS_SAMPLE_DIMENSION 0\n#define LENS_SAMPLE_DIMENSION 2\n#define PATH_SAMPLE_DIMENSION 4\n\n// This is 2 for two dimensions and 2 as we use it for two purposese: NEE and path connection\n#define PATH_SAMPLE_DIMENSION_MULTIPLIER (2 * 2)\n\nvec3 randomDirection(const int dimensionIndex) {\n#ifdef SOLUTION_BOUNCE\n#else\n  // Put yout code to compute a random direction in 3D here\n  return vec3(0);\n#endif\n}\n\nvec3 getEmission(const Material material, const vec3 normal) {\n#ifdef SOLUTION_LIGHT  \n#else\n  \t// This is wrong. It just returns the diffuse color so that you see something to be sure it is working.\n  \treturn material.diffuse;\n#endif\n}\n\nvec3 getReflectance(\n  const Material material,\n  const vec3 normal,\n  const vec3 inDirection,\n  const vec3 outDirection)\n{\n#ifdef SOLUTION_THROUGHPUT    \n#else\n  return vec3(1.0);\n#endif \n}\n\nvec3 getGeometricTerm(\n  const Material material,\n  const vec3 normal,\n  const vec3 inDirection,\n  const vec3 outDirection)\n{\n#ifdef SOLUTION_THROUGHPUT  \n#else\n  return vec3(1.0);\n#endif \n}\n\nmat4 rotationMatrixFromAngleAxis(float angle, vec3 axis)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           \n                oc * axis.x * axis.y - axis.z * s,  \n                oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  \n                oc * axis.y * axis.y + c,           \n                oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  \n                oc * axis.y * axis.z + axis.x * s,  \n                oc * axis.z * axis.z + c,           0.0,\n                0.0,                                \n                0.0,                                \n                0.0,                                \n                1.0);\n}\n\nvec3 getEmitterPosition(const vec3 position, const Sphere sphere, const int dimensionIndex) {   \n  // This is a simplified version: Just report the sphere center. Will not do well with visibility.\n  //return sphere.position;\n  \n  // This is the wrong simplified version: Take a random surface point.\n  //return sphere.position + randomDirection(dimensionIndex) * sphere.radius;\n\n  // Well we stick our fingers in\n  // The ground, heave and \n  // Turn the world around\n\n  // This has three main steps: \n  //   1) Make a direction\n  //   2) Orient it so it points to the sphere\n  //   3) Find a point on the sphere along this direction\n  \n  // Step 1) Make a random direction in a cone orientedd along th up-pointing z direction\n  // .. the opening angle of a sphere in a certain distance\n  float apexAngle = asin(sphere.radius / length(position - sphere.position));\n \n  // The rotation around the z axis\n  float phi = sample(dimensionIndex + 1) * 2.0 * M_PI;  \n  \n  // z is the cosine of the angle.\n  // We need a random cosine of the angle (which is notthe same as the cosine of a random angle!)\n  float z = mix(1.0, cos(apexAngle), sample(dimensionIndex + 0));\n  vec3 alignedDirection = vec3(sqrt(1.0-z*z) * cos(phi), sqrt(1.0-z*z) * sin(phi), z);\n  \n  // Step 2) Rotate the z axis-aligned dirction to point into the direction of the sphere\n  vec3 direction = normalize(sphere.position - position);    \n  float rotationAngle = acos(dot(direction, vec3(0,0,1)));\n  vec3 rotationAxis = cross(direction, vec3(0,0,1));  \n  mat4 rotationMatrix = rotationMatrixFromAngleAxis(rotationAngle, rotationAxis);\n  vec3 worldDirection = (rotationMatrix * vec4(alignedDirection, 0)).xyz;\n  \n  // Step 3) Send a ray. it feels this should be easier, but Tobias does not see it.\n  Ray emitterRay;\n  emitterRay.origin = position;\n  emitterRay.direction = worldDirection;\n  return intersectSphere(emitterRay, sphere, 0.01, 100000.0).position;\n}\n\nvec3 samplePath(const Scene scene, const Ray initialRay) {\n  \n  // Initial result is black\n  vec3 result = vec3(0);\n  \n  Ray incomingRay = initialRay;\n  vec3 throughput = vec3(1.0);\n  for(int i = 0; i < maxPathLength; i++) {\n    HitInfo hitInfo = intersectScene(scene, incomingRay, 0.001, 10000.0); \n    \n    if(!hitInfo.hit) return result;\n         \n#ifdef SOLUTION_NEXT_EVENT_ESTIMATION    \n    // Loop over all spheres emitting light\n#else\n    // Put the next event-estimation code here\n    // This might need to change with NEE\n    result += throughput * getEmission(hitInfo.material, hitInfo. normal);  \n#endif\n        \n    Ray outgoingRay;\n#ifdef SOLUTION_BOUNCE\n#else\n   // Put your code to compute the next ray here\n#endif    \n\n#ifdef SOLUTION_THROUGHPUT\n#else\n    // Replace the line below for proper throughput computation\n    throughput *= 0.1;    \n#endif\n    \n    // With importance sampling, this value woudl change\n    float probability = 1.0;\n    throughput /= probability;\n    \n#ifdef SOLUTION_BOUNCE\n#else\n    // Put some handling of the next and the current ray here\n#endif    \n  }  \n  return result;\n}\n\nuniform ivec2 resolution;\nRay getFragCoordRay(const vec2 fragCoord) {\n  \n  \tfloat sensorDistance = 1.0;\n  \tvec3 origin = vec3(0, 0, sensorDistance);\n  \tvec2 sensorMin = vec2(-1, -0.5);\n  \tvec2 sensorMax = vec2(1, 0.5);\n  \tvec2 pixelSize = (sensorMax - sensorMin) / vec2(resolution);\n    vec3 direction = normalize(vec3(sensorMin + pixelSize * fragCoord, -sensorDistance));\n  \n  \tfloat apertureSize = 0.0;\n  \tfloat focalPlane = 100.0;\n  \tvec3 sensorPosition = origin + focalPlane * direction;  \n  \torigin.xy += apertureSize * (sample2(LENS_SAMPLE_DIMENSION) - vec2(0.5));  \n  \tdirection = normalize(sensorPosition - origin);\n  \n  \treturn Ray(origin, direction);\n}\n\nvec3 colorForFragment(const Scene scene, const vec2 fragCoord) {      \n  \tinitRandomSequence(); \n  \n#ifdef SOLUTION_AA  \n#else\n  \t// CHnage this to get anti-aliasing\n\tvec2 sampleCoord = fragCoord;\n#endif\n    return samplePath(scene, getFragCoordRay(sampleCoord));\n}\n\n\nvoid loadScene1(inout Scene scene) {\n\n  scene.spheres[0].position = vec3( 7, -2, -12);\n  scene.spheres[0].radius = 2.0;\n#ifdef SOLUTION_LIGHT  \n#endif\n  scene.spheres[0].material.diffuse = vec3(0.0);\n  scene.spheres[0].material.specular = vec3(0.0);\n  scene.spheres[0].material.glossiness = 10.0;\n\n  scene.spheres[1].position = vec3(-8, 4, -13);\n  scene.spheres[1].radius = 1.0;\n#ifdef SOLUTION_LIGHT  \n#endif\n  scene.spheres[1].material.diffuse = vec3(0.0);\n  scene.spheres[1].material.specular = vec3(0.0);\n  scene.spheres[1].material.glossiness = 10.0;\n\n  scene.spheres[2].position = vec3(-2, -2, -12);\n  scene.spheres[2].radius = 3.0;\n#ifdef SOLUTION_LIGHT  \n#endif  \n  scene.spheres[2].material.diffuse = vec3(0.2, 0.5, 0.8);\n  scene.spheres[2].material.specular = vec3(0.8);\n  scene.spheres[2].material.glossiness = 40.0;  \n\n  scene.spheres[3].position = vec3(3, -3.5, -14);\n  scene.spheres[3].radius = 1.0;\n#ifdef SOLUTION_LIGHT  \n#endif  \n  scene.spheres[3].material.diffuse = vec3(0.9, 0.8, 0.8);\n  scene.spheres[3].material.specular = vec3(1.0);\n  scene.spheres[3].material.glossiness = 10.0;  \n\n  scene.planes[0].normal = vec3(0, 1, 0);\n  scene.planes[0].d = 4.5;\n#ifdef SOLUTION_LIGHT    \n#endif\n  scene.planes[0].material.diffuse = vec3(0.8);\n  scene.planes[0].material.specular = vec3(0);\n  scene.planes[0].material.glossiness = 50.0;    \n\n  scene.planes[1].normal = vec3(0, 0, 1);\n  scene.planes[1].d = 18.5;\n#ifdef SOLUTION_LIGHT    \n#endif\n  scene.planes[1].material.diffuse = vec3(0.9, 0.6, 0.3);\n  scene.planes[1].material.specular = vec3(0.02);\n  scene.planes[1].material.glossiness = 3000.0;\n\n  scene.planes[2].normal = vec3(1, 0,0);\n  scene.planes[2].d = 10.0;\n#ifdef SOLUTION_LIGHT    \n#endif\n  scene.planes[2].material.diffuse = vec3(0.2);\n  scene.planes[2].material.specular = vec3(0.1);\n  scene.planes[2].material.glossiness = 100.0; \n\n  scene.planes[3].normal = vec3(-1, 0,0);\n  scene.planes[3].d = 10.0;\n#ifdef SOLUTION_LIGHT    \n#endif\n  scene.planes[3].material.diffuse = vec3(0.2);\n  scene.planes[3].material.specular = vec3(0.1);\n  scene.planes[3].material.glossiness = 100.0; \n}\n\nvoid main() {\n  // Setup scene\n  Scene scene;\n  loadScene1(scene);\n\n  // compute color for fragment\n  gl_FragColor.rgb = colorForFragment(scene, gl_FragCoord.xy);\n  gl_FragColor.a = 1.0;\n}\n`,\n\t\tdescription: ``,\n\t\twrapFunctionStart: ``,\n\t\twrapFunctionEnd: ``\n\t});\n\n\tUI.tabs.push(\n\t\t{\n\t\tvisible: true,\n\t\ttype: `x-shader/x-fragment`,\n\t\ttitle: `Tonemapping`,\n\t\tid: `CopyFS`,\n\t\tinitialValue: `precision highp float;\n\nuniform sampler2D radianceTexture;\nuniform int sampleCount;\nuniform ivec2 resolution;\n\nvec3 tonemap(vec3 color, float maxLuminance, float gamma) {\n\tfloat luminance = length(color);\n\t//float scale =  luminance /  maxLuminance;\n\tfloat scale =  luminance / (maxLuminance * luminance + 0.0000001);\n  \treturn max(vec3(0.0), pow(scale * color, vec3(1.0 / gamma)));\n}\n\nvoid main(void) {\n  vec3 texel = texture2D(radianceTexture, gl_FragCoord.xy / vec2(resolution)).rgb;\n  vec3 radiance = texel / float(sampleCount);\n  gl_FragColor.rgb = tonemap(radiance, 1.0, 1.6);\n  gl_FragColor.a = 1.0;\n}\n`,\n\t\tdescription: ``,\n\t\twrapFunctionStart: ``,\n\t\twrapFunctionEnd: ``\n\t});\n\n\tUI.tabs.push(\n\t\t{\n\t\tvisible: false,\n\t\ttype: `x-shader/x-vertex`,\n\t\ttitle: ``,\n\t\tid: `VS`,\n\t\tinitialValue: `\n\tattribute vec3 position;\n\tvoid main(void) {\n\t\tgl_Position = vec4(position, 1.0);\n\t}\n`,\n\t\tdescription: ``,\n\t\twrapFunctionStart: ``,\n\t\twrapFunctionEnd: ``\n\t});\n\n\t return UI; \n}//!setup\n\n\nfunction getShader(gl, id) {\n\n\t\tgl.getExtension('OES_texture_float');\n\t\t//alert(gl.getSupportedExtensions());\n\n\tvar shaderScript = document.getElementById(id);\n\tif (!shaderScript) {\n\t\treturn null;\n\t}\n\n\tvar str = \"\";\n\tvar k = shaderScript.firstChild;\n\twhile (k) {\n\t\tif (k.nodeType == 3) {\n\t\t\tstr += k.textContent;\n\t\t}\n\t\tk = k.nextSibling;\n\t}\n\n\tvar shader;\n\tif (shaderScript.type == \"x-shader/x-fragment\") {\n\t\tshader = gl.createShader(gl.FRAGMENT_SHADER);\n\t} else if (shaderScript.type == \"x-shader/x-vertex\") {\n\t\tshader = gl.createShader(gl.VERTEX_SHADER);\n\t} else {\n\t\treturn null;\n\t}\n\n    console.log(str);\n\tgl.shaderSource(shader, str);\n\tgl.compileShader(shader);\n\n\tif (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n\t\talert(gl.getShaderInfoLog(shader));\n\t\treturn null;\n\t}\n\n\treturn shader;\n}\n\nfunction RaytracingDemo() {\n}\n\nfunction initShaders() {\n\n\ttraceProgram = gl.createProgram();\n\tgl.attachShader(traceProgram, getShader(gl, \"VS\"));\n\tgl.attachShader(traceProgram, getShader(gl, \"TraceFS\"));\n\tgl.linkProgram(traceProgram);\n\tgl.useProgram(traceProgram);\n\ttraceProgram.vertexPositionAttribute = gl.getAttribLocation(traceProgram, \"position\");\n\tgl.enableVertexAttribArray(traceProgram.vertexPositionAttribute);\n\n\tcopyProgram = gl.createProgram();\n\tgl.attachShader(copyProgram, getShader(gl, \"VS\"));\n\tgl.attachShader(copyProgram, getShader(gl, \"CopyFS\"));\n\tgl.linkProgram(copyProgram);\n\tgl.useProgram(copyProgram);\n\ttraceProgram.vertexPositionAttribute = gl.getAttribLocation(copyProgram, \"position\");\n\tgl.enableVertexAttribArray(copyProgram.vertexPositionAttribute);\n\n}\n\nfunction initBuffers() {\n\ttriangleVertexPositionBuffer = gl.createBuffer();\n\tgl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);\n\t\n\tvar vertices = [\n\t\t -1,  -1,  0,\n\t\t -1,  1,  0,\n\t\t 1,  1,  0,\n\n\t\t -1,  -1,  0,\n\t\t 1,  -1,  0,\n\t\t 1,  1,  0,\n\t ];\n\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n\ttriangleVertexPositionBuffer.itemSize = 3;\n\ttriangleVertexPositionBuffer.numItems = 3 * 2;\n}\n\n\nfunction tick() {\n\t\n// 1st pass: Trace\n\tgl.bindFramebuffer(gl.FRAMEBUFFER, rttFramebuffer);\n \n\tgl.useProgram(traceProgram);\n  \tgl.uniform1i(gl.getUniformLocation(traceProgram, \"globalSeed\"), Math.random() * 32768.0);\n\tgl.uniform1i(gl.getUniformLocation(traceProgram, \"baseSampleIndex\"), getCurrentFrame()); \t\n\tgl.uniform2i(\n\t\tgl.getUniformLocation(traceProgram, \"resolution\"), \n\t\tgetRenderTargetWidth(), \n\t\tgetRenderTargetHeight());\n\t\t\n\tgl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);\n\tgl.vertexAttribPointer(\n\t\ttraceProgram.vertexPositionAttribute, \n\t\ttriangleVertexPositionBuffer.itemSize, \n\t\tgl.FLOAT, \n\t\tfalse, \n\t\t0,\n\t\t0);\n\t\n    \tgl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);\n    \n\tgl.disable(gl.DEPTH_TEST);\n\tgl.enable(gl.BLEND);\n\tgl.blendFunc(gl.ONE, gl.ONE);\n\n\tgl.drawArrays(gl.TRIANGLES, 0, triangleVertexPositionBuffer.numItems);\n\n// 2nd pass: Average\n   \tgl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n\tgl.useProgram(copyProgram);\n\tgl.uniform1i(gl.getUniformLocation(copyProgram, \"sampleCount\"), getCurrentFrame() + 1); \n  \t\t\n\tgl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);\n\tgl.vertexAttribPointer(\n\t\tcopyProgram.vertexPositionAttribute, \n\t\ttriangleVertexPositionBuffer.itemSize, \n\t\tgl.FLOAT, \n\t\tfalse, \n\t\t0,\n\t\t0);\n\t\n    \tgl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);\n    \n\tgl.disable(gl.DEPTH_TEST);\n\tgl.disable(gl.BLEND);\n\n\tgl.activeTexture(gl.TEXTURE0);\n    \tgl.bindTexture(gl.TEXTURE_2D, rttTexture);\n\tgl.uniform1i(gl.getUniformLocation(copyProgram, \"radianceTexture\"), 0);\n\tgl.uniform2i(\n\t\tgl.getUniformLocation(copyProgram, \"resolution\"), \n\t\tgetRenderTargetWidth(), \n\t\tgetRenderTargetHeight());\n\t\n\tgl.drawArrays(gl.TRIANGLES, 0, triangleVertexPositionBuffer.numItems);\n\n\tgl.bindTexture(gl.TEXTURE_2D, null);\n}\n\nfunction init() {\t\n\tinitShaders();\n\tinitBuffers();\n\tgl.clear(gl.COLOR_BUFFER_BIT);\t\n\n\trttFramebuffer = gl.createFramebuffer();\n\tgl.bindFramebuffer(gl.FRAMEBUFFER, rttFramebuffer);\n\t\n\trttTexture = gl.createTexture();\n\tgl.bindTexture(gl.TEXTURE_2D, rttTexture);\n    \tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    \tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n\t\n\tgl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, getRenderTargetWidth(), getRenderTargetHeight(), 0, gl.RGBA, gl.FLOAT, null);  \n    \t\n\tgl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, rttTexture, 0);\n}\n\nvar oldWidth = 0;\nvar oldTraceProgram;\nvar oldCopyProgram;\nfunction compute(canvas) {\n\t\n\tif(\tgetRenderTargetWidth() != oldWidth || \n\t\toldTraceProgram != document.getElementById(\"TraceFS\") ||\n\t\toldCopyProgram !=  document.getElementById(\"CopyFS\"))\n\t{\n\t\tinit();\n\t\t\t\t\t\n\t\toldWidth = getRenderTargetWidth();\n\t\toldTraceProgram = document.getElementById(\"TraceFS\");\n\t\toldCopyProgram = document.getElementById(\"CopyFS\");\t\n\t}\n\n\ttick();\n}\n"], "categories": ["Demos", "Demos", "Demos", "Coursework", "Coursework", "Coursework"], "pictures": ["https://uclcg.github.io/uclcg/demos/thumb_camera.png", "https://uclcg.github.io/uclcg/demos/thumb_splines.png", "https://uclcg.github.io/uclcg/demos/thumb_openGL.png", "https://uclcg.github.io/uclcg/demos/cw_thumb1.png", "https://uclcg.github.io/uclcg/demos/cw_thumb2.png", "https://uclcg.github.io/uclcg/demos/cw_thumb3.png"], "niceNames": [" Demo - Simple Camera", " Demo - Animated Splines", " Demo - Animated OpenGL", " Coursework 1 - 2021/22", " Coursework 2 - 2021/22", " Coursework 3 - 2021/22"], "shortDescriptions": [" A simple camera model.", " An animated demo for splines.", " An animated demo for OpenGL.", " Coursework 1 - Ray Tracing", " Coursework 2 - Rasterization", " Coursework 3 - Path Tracing"], "authors": ["None", "None", "None", "None", "None", "None"], "hidden": ["false", "false", "false", "false", "false", "false"]}