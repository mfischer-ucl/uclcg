{"0": "function setup()\n", "1": "{\n", "2": "\tUI = {};\n", "3": "\tUI.tabs = [];\n", "4": "\tUI.titleLong = 'Simple Camera';\n", "5": "\tUI.titleShort = 'cameraSimple';\n", "6": "\tUI.numFrames = 1000;\n", "7": "\tUI.maxFPS = 24;\n", "8": "\tUI.tabs.push(\n", "9": "\t\t{\n", "10": "\t\tvisible: true,\n", "11": "\t\ttype: `x-shader/x-fragment`,\n", "12": "\t\ttitle: `Ray Generation`,\n", "13": "\t\tid: `RaytracingDemoFS`,\n", "14": "\t\tinitialValue: `precision highp float;\n", "15": "\n", "16": "struct Ray {\n", "17": "  vec3 origin;\n", "18": "  vec3 direction;\n", "19": "};\n", "20": "\n", "21": "struct Sphere {\n", "22": "  vec3 position;\n", "23": "  float radius;\n", "24": "};\n", "25": "\n", "26": "uniform vec2 g_resolution;\n", "27": "\n", "28": "bool intersectSphere(const Sphere sphere, const Ray ray) {\n", "29": "  vec3 toOrigin = ray.origin - sphere.position;\n", "30": "  float a = dot(ray.direction, ray.direction);\n", "31": "  float b = 2.0 * dot(toOrigin, ray.direction);\n", "32": "  float c = dot(toOrigin, toOrigin) - sphere.radius * sphere.radius;\n", "33": "  float discriminant = b * b - 4.0 * a * c;\n", "34": "\n", "35": "  if(discriminant < 0.0) return false;\n", "36": "\n", "37": "  float t0 = (-b - sqrt(discriminant)) / (2.0 * a);\n", "38": "  float t1 = (-b + sqrt(discriminant)) / (2.0 * a);\n", "39": "\n", "40": "  return t0 > 0.0 || t1 > 0.0;\n", "41": "}\n", "42": "\n", "43": "vec3 simpleCamera(const ivec2 pixelCoord) {\n", "44": "  const int sphereCount = 2;\n", "45": "\n", "46": "  // Array of spheres\n", "47": "  Sphere spheres[sphereCount];\n", "48": "\n", "49": "  // Initialize first sphere\n", "50": "  spheres[0].position = vec3(0, -2, -10);\n", "51": "  spheres[0].radius = 3.0;\n", "52": "  // Initialize second sphere\n", "53": "  spheres[1].position = vec3(3, -1, -5);\n", "54": "  spheres[1].radius = 1.0;\n", "55": "\n", "56": "  float d = 1.0;\n", "57": "\n", "58": "  // Initialize a ray\n", "59": "  Ray ray;\n", "60": "  ray.origin = vec3(0, 0, d);\n", "61": "\n", "62": "  // Construct ray direction\n", "63": "  vec2 windowMin = vec2(-0.5,-0.5);\n", "64": "  vec2 windowMax = vec2(0.5,0.5);\n", "65": "  float width = (windowMax.x - windowMin.x) / g_resolution.x;\n", "66": "  float height = (windowMax.y - windowMin.y) / g_resolution.y;\n", "67": "  // Do not need to add 0.5, gl_FragCoord contains pixel centers\n", "68": "  ray.direction = vec3( windowMin.x + width * gl_FragCoord.x,\n", "69": "                       \twindowMin.y + height * gl_FragCoord.y,\n", "70": "                        -d);\n", "71": "\n", "72": "  // Correct for window aspect ratio\n", "73": "  float aspect = g_resolution.x / g_resolution.y;\n", "74": "  ray.direction = ray.direction * vec3(aspect,1,1);\n", "75": "\n", "76": "  // Visualize the direction as a color\n", "77": "  // return ray.direction;\n", "78": "\n", "79": "  // Loop over all spheres\n", "80": "  for(int i = 0; i < sphereCount; i++) {\n", "81": "    // Test for intersection\n", "82": "    if(intersectSphere(spheres[i], ray)) {\n", "83": "      // Mark as white if it intersects\n", "84": "      return vec3(1);\n", "85": "    }\n", "86": "  }\n", "87": "  return vec3(0);\n", "88": "}\n", "89": "\n", "90": "void main() {\n", "91": "  gl_FragColor = vec4(simpleCamera(ivec2(gl_FragCoord.xy)), 1);\n", "92": "}`,\n", "93": "\t\tdescription: ``,\n", "94": "\t\twrapFunctionStart: ``,\n", "95": "\t\twrapFunctionEnd: ``\n", "96": "\t});\n", "97": "\n", "98": "\tUI.tabs.push(\n", "99": "\t\t{\n", "100": "\t\tvisible: false,\n", "101": "\t\ttype: `x-shader/x-vertex`,\n", "102": "\t\ttitle: `Something we would not like to see`,\n", "103": "\t\tid: `RaytracingDemoVS`,\n", "104": "\t\tinitialValue: ` attribute vec3 position;\n", "105": "    uniform mat4 modelViewMatrix;\n", "106": "    uniform mat4 projectionMatrix;\n", "107": "    void main(void) {\n", "108": "        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n", "109": "    }`,\n", "110": "\t\tdescription: ``,\n", "111": "\t\twrapFunctionStart: ``,\n", "112": "\t\twrapFunctionEnd: ``\n", "113": "\t});\n", "114": "\n", "115": "\t return UI; \n", "116": "}//!setup\n", "117": "\n", "118": "var gl;\n", "119": "function initGL(canvas) {\n", "120": "\ttry {\n", "121": "\t\tgl = canvas.getContext(\"webgl\");\n", "122": "\t\tgl.viewportWidth = canvas.width;\n", "123": "\t\tgl.viewportHeight = canvas.height;\n", "124": "\t} catch (e) {\n", "125": "\t}\n", "126": "\tif (!gl) {\n", "127": "\t\talert(\"Could not initialise WebGL, sorry :-(\");\n", "128": "\t}\n", "129": "}\n", "130": "\n", "131": "function getShader(gl, id) {\n", "132": "\tvar shaderScript = document.getElementById(id);\n", "133": "\tif (!shaderScript) {\n", "134": "\t\treturn null;\n", "135": "\t}\n", "136": "\n", "137": "\tvar str = \"\";\n", "138": "\tvar k = shaderScript.firstChild;\n", "139": "\twhile (k) {\n", "140": "\t\tif (k.nodeType == 3) {\n", "141": "\t\t\tstr += k.textContent;\n", "142": "\t\t}\n", "143": "\t\tk = k.nextSibling;\n", "144": "\t}\n", "145": "\n", "146": "\tvar shader;\n", "147": "\tif (shaderScript.type == \"x-shader/x-fragment\") {\n", "148": "\t\tshader = gl.createShader(gl.FRAGMENT_SHADER);\n", "149": "\t} else if (shaderScript.type == \"x-shader/x-vertex\") {\n", "150": "\t\tshader = gl.createShader(gl.VERTEX_SHADER);\n", "151": "\t} else {\n", "152": "\t\treturn null;\n", "153": "\t}\n", "154": "\n", "155": "\tgl.shaderSource(shader, str);\n", "156": "\tgl.compileShader(shader);\n", "157": "\n", "158": "\tif (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n", "159": "\t\talert(gl.getShaderInfoLog(shader));\n", "160": "\t\treturn null;\n", "161": "\t}\n", "162": "\n", "163": "\treturn shader;\n", "164": "}\n", "165": "\n", "166": "function RaytracingDemo() {\n", "167": "}\n", "168": "\n", "169": "RaytracingDemo.prototype.initShaders = function() {\n", "170": "\n", "171": "\tthis.shaderProgram = gl.createProgram();\n", "172": "\n", "173": "\tgl.attachShader(this.shaderProgram, getShader(gl, \"RaytracingDemoVS\"));\n", "174": "\tgl.attachShader(this.shaderProgram, getShader(gl, \"RaytracingDemoFS\"));\n", "175": "\tgl.linkProgram(this.shaderProgram);\n", "176": "\n", "177": "\tif (!gl.getProgramParameter(this.shaderProgram, gl.LINK_STATUS)) {\n", "178": "\t\talert(\"Could not initialise shaders\");\n", "179": "\t}\n", "180": "\n", "181": "\tgl.useProgram(this.shaderProgram);\n", "182": "\n", "183": "\tthis.shaderProgram.vertexPositionAttribute = gl.getAttribLocation(this.shaderProgram, \"position\");\n", "184": "\tgl.enableVertexAttribArray(this.shaderProgram.vertexPositionAttribute);\n", "185": "\n", "186": "\tthis.shaderProgram.projectionMatrixUniform = gl.getUniformLocation(this.shaderProgram, \"projectionMatrix\");\n", "187": "    this.shaderProgram.modelviewMatrixUniform = gl.getUniformLocation(this.shaderProgram, \"modelViewMatrix\");\n", "188": "\n", "189": "    // Add resolution uniform\n", "190": "    gl.uniform2f(\n", "191": "\t\tgl.getUniformLocation(this.shaderProgram, \"g_resolution\"),\n", "192": "\t\tgetRenderTargetWidth(),\n", "193": "\t\tgetRenderTargetHeight());\n", "194": "}\n", "195": "\n", "196": "RaytracingDemo.prototype.initBuffers = function() {\n", "197": "\tthis.triangleVertexPositionBuffer = gl.createBuffer();\n", "198": "\tgl.bindBuffer(gl.ARRAY_BUFFER, this.triangleVertexPositionBuffer);\n", "199": "\n", "200": "\tvar vertices = [\n", "201": "\t\t -1,  -1,  0,\n", "202": "\t\t -1,  1,  0,\n", "203": "\t\t 1,  1,  0,\n", "204": "\n", "205": "\t\t -1,  -1,  0,\n", "206": "\t\t 1,  -1,  0,\n", "207": "\t\t 1,  1,  0,\n", "208": "\t ];\n", "209": "\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n", "210": "\tthis.triangleVertexPositionBuffer.itemSize = 3;\n", "211": "\tthis.triangleVertexPositionBuffer.numItems = 3 * 2;\n", "212": "}\n", "213": "\n", "214": "RaytracingDemo.prototype.drawScene = function() {\n", "215": "\n", "216": "\tvar perspectiveMatrix = new J3DIMatrix4();\n", "217": "\tperspectiveMatrix.setUniform(gl, this.shaderProgram.projectionMatrixUniform, false);\n", "218": "\n", "219": "\tvar modelViewMatrix = new J3DIMatrix4();\n", "220": "\tmodelViewMatrix.setUniform(gl, this.shaderProgram.modelviewMatrixUniform, false);\n", "221": "\n", "222": "\tgl.bindBuffer(gl.ARRAY_BUFFER, this.triangleVertexPositionBuffer);\n", "223": "\tgl.vertexAttribPointer(this.shaderProgram.vertexPositionAttribute, this.triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);\n", "224": "\n", "225": "\tgl.drawArrays(gl.TRIANGLES, 0, this.triangleVertexPositionBuffer.numItems);\n", "226": "}\n", "227": "\n", "228": "RaytracingDemo.prototype.run = function() {\n", "229": "\tthis.initShaders();\n", "230": "\tthis.initBuffers();\n", "231": "\n", "232": "\tgl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);\n", "233": "\tgl.clear(gl.COLOR_BUFFER_BIT);\n", "234": "\n", "235": "\tthis.drawScene();\n", "236": "};\n", "237": "\n", "238": "function init() {\n", "239": "\n", "240": "\n", "241": "\tenv = new RaytracingDemo();\n", "242": "\tenv.run();\n", "243": "\n", "244": "    return env;\n", "245": "}\n", "246": "\n", "247": "function compute(canvas)\n", "248": "{\n", "249": "    env.initShaders();\n", "250": "    env.initBuffers();\n", "251": "\n", "252": "    gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);\n", "253": "    gl.clear(gl.COLOR_BUFFER_BIT);\n", "254": "\n", "255": "    env.drawScene();\n", "256": "}\n"}