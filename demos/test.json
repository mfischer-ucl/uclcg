{"jsFiles": ["function setup()\n{\n\tUI = {};\n\tUI.tabs = [];\n\tUI.titleLong = 'Ray Tracer';\n\tUI.titleShort = 'RayTracerSimple';\n\tUI.numFrames = 1000;\n\tUI.maxFPS = 24;\n\tUI.renderWidth = 800;\n\tUI.renderHeight = 400;\n\n\tUI.tabs.push(\n\t\t{\n\t\tvisible: true,\n\t\ttype: `x-shader/x-fragment`,\n\t\ttitle: `RaytracingDemoFS - GL`,\n\t\tid: `RaytracingDemoFS`,\n\t\tinitialValue: `//#define SOLUTION_CYLINDER_AND_PLANE\n//#define SOLUTION_MATERIAL\n//#define SOLUTION_SHADOW\n//#define SOLUTION_REFLECTION_REFRACTION\n//#define SOLUTION_FRESNEL\n\nprecision highp float;\nuniform ivec2 viewport; \n\nstruct PointLight {\n  vec3 position;\n  vec3 color;\n};\n\nstruct Material {\n  vec3  diffuse;\n  vec3  specular;\n  float glossiness;\n#ifdef SOLUTION_MATERIAL\n  // Put the variables for reflection and refraction here\n#else\n#endif\n};\n\nstruct Sphere {\n  vec3 position;\n  float radius;\n  Material material;\n};\n\nstruct Plane {\n  vec3 normal;\n  float d;\n  Material material;\n};\n\nstruct Cylinder {\n  vec3 position;\n  vec3 direction;  \n  float radius;\n  Material material;\n};\n\nconst int lightCount = 2;\nconst int sphereCount = 3;\nconst int planeCount = 1;\nconst int cylinderCount = 2;\n\nstruct Scene {\n  vec3 ambient;\n  PointLight[lightCount] lights;\n  Sphere[sphereCount] spheres;\n  Plane[planeCount] planes;\n  Cylinder[cylinderCount] cylinders;\n};\n\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\n\n// Contains all information pertaining to a ray/object intersection\nstruct HitInfo {\n  bool hit;\n  float t;\n  vec3 position;\n  vec3 normal;\n  Material material;\n  bool enteringPrimitive;\n};\n\nHitInfo getEmptyHit() {\n  return HitInfo(\n    false, \n    0.0, \n    vec3(0.0), \n    vec3(0.0), \n#ifdef SOLUTION_MATERIAL\n#else\n  \t// Depending on the material definition extension you make, this constructor call might need to be extened as well\n    Material(vec3(0.0), vec3(0.0), 0.0),\n#endif\n    false);\n}\n\n// Sorts the two t values such that t1 is smaller than t2\nvoid sortT(inout float t1, inout float t2) {\n  // Make t1 the smaller t\n  if(t2 < t1)  {\n    float temp = t1;\n    t1 = t2;\n    t2 = temp;\n  }\n}\n\n// Tests if t is in an interval\nbool isTInInterval(const float t, const float tMin, const float tMax) {\n  return t > tMin && t < tMax;\n}\n\n// Get the smallest t in an interval\nbool getSmallestTInInterval(float t0, float t1, const float tMin, const float tMax, inout float smallestTInInterval) {\n  \n  sortT(t0, t1);\n  \n  // As t0 is smaller, test this first\n  if(isTInInterval(t0, tMin, tMax)) {\n  \tsmallestTInInterval = t0;\n    return true;\n  }\n  \n  // If t0 was not in the interval, still t1 could be\n  if(isTInInterval(t1, tMin, tMax)) {\n  \tsmallestTInInterval = t1;\n    return true;\n  }  \n  \n  // None was\n  return false;\n}\n\nHitInfo intersectSphere(const Ray ray, const Sphere sphere, const float tMin, const float tMax) {\n              \n    vec3 to_sphere = ray.origin - sphere.position;\n  \n    float a = dot(ray.direction, ray.direction);\n    float b = 2.0 * dot(ray.direction, to_sphere);\n    float c = dot(to_sphere, to_sphere) - sphere.radius * sphere.radius;\n    float D = b * b - 4.0 * a * c;\n    if (D > 0.0)\n    {\n\t\tfloat t0 = (-b - sqrt(D)) / (2.0 * a);\n\t\tfloat t1 = (-b + sqrt(D)) / (2.0 * a);\n      \n      \tfloat smallestTInInterval;\n      \tif(!getSmallestTInInterval(t0, t1, tMin, tMax, smallestTInInterval)) {\n          return getEmptyHit();\n        }\n      \n      \tvec3 hitPosition = ray.origin + smallestTInInterval * ray.direction;      \n\t\t\n\t\t//Checking if we're inside the sphere by checking if the ray's origin is inside. If we are, then the normal \n\t\t//at the intersection surface points towards the center. Otherwise, if we are outside the sphere, then the normal \n\t\t//at the intersection surface points outwards from the sphere's center. This is important for refraction.\n      \tvec3 normal = \n          \tlength(ray.origin - sphere.position) < sphere.radius + 0.001? \n          \t-normalize(hitPosition - sphere.position): \n      \t\tnormalize(hitPosition - sphere.position);      \n\t\t\n\t\t//Checking if we're inside the sphere by checking if the ray's origin is inside, but this time for IOR bookkeeping. \n\t\t//If we are inside, set a flag to say we're leaving. If we are outside, set the flag to say we're entering.\n\t\t//This is also important for refraction.\n\t\tbool enteringPrimitive = \n          \tlength(ray.origin - sphere.position) < sphere.radius + 0.001? \n          \tfalse:\n\t\t    true; \n\n        return HitInfo(\n          \ttrue,\n          \tsmallestTInInterval,\n          \thitPosition,\n          \tnormal,\n          \tsphere.material,\n\t\t\tenteringPrimitive);\n    }\n    return getEmptyHit();\n}\n\nHitInfo intersectPlane(const Ray ray,const Plane plane, const float tMin, const float tMax) {\n#ifdef SOLUTION_CYLINDER_AND_PLANE\n#endif  \n    return getEmptyHit();\n}\n\nfloat lengthSquared(vec3 x) {\n  return dot(x, x);\n}\n\nHitInfo intersectCylinder(const Ray ray, const Cylinder cylinder, const float tMin, const float tMax) {\n#ifdef SOLUTION_CYLINDER_AND_PLANE\n#endif  \n    return getEmptyHit();\n}\n\nHitInfo getBetterHitInfo(const HitInfo oldHitInfo, const HitInfo newHitInfo) {\n\tif(newHitInfo.hit)\n  \t\tif(newHitInfo.t < oldHitInfo.t)  // No need to test for the interval, this has to be done per-primitive\n          return newHitInfo;\n  \treturn oldHitInfo;\n}\n\nHitInfo intersectScene(const Scene scene, const Ray ray, const float tMin, const float tMax) {\n  HitInfo bestHitInfo;\n  bestHitInfo.t = tMax;\n  bestHitInfo.hit = false;\n  for (int i = 0; i < cylinderCount; ++i) {\n    bestHitInfo = getBetterHitInfo(bestHitInfo, intersectCylinder(ray, scene.cylinders[i], tMin, tMax));\n  }\n  for (int i = 0; i < sphereCount; ++i) {\n    bestHitInfo = getBetterHitInfo(bestHitInfo, intersectSphere(ray, scene.spheres[i], tMin, tMax));\n  }\n  for (int i = 0; i < planeCount; ++i) {\n    bestHitInfo = getBetterHitInfo(bestHitInfo, intersectPlane(ray, scene.planes[i], tMin, tMax));\n  }\n  \n  return bestHitInfo;\n}\n\nvec3 shadeFromLight(\n  const Scene scene,\n  const Ray ray,\n  const HitInfo hit_info,\n  const PointLight light)\n{ \n  vec3 hitToLight = light.position - hit_info.position;\n  \n  vec3 lightDirection = normalize(hitToLight);\n  vec3 viewDirection = normalize(hit_info.position - ray.origin);\n  vec3 reflectedDirection = reflect(viewDirection, hit_info.normal);\n  float diffuse_term = max(0.0, dot(lightDirection, hit_info.normal));\n  float specular_term  = pow(max(0.0, dot(lightDirection, reflectedDirection)), hit_info.material.glossiness);\n\n#ifdef SOLUTION_SHADOW\n  // Put your shadow test here\n#else\n  \n  float visibility = 1.0;\n#endif\n  \n  return \tvisibility * \n    \t\tlight.color * (\n    \t\tspecular_term * hit_info.material.specular +\n      \t\tdiffuse_term * hit_info.material.diffuse);\n}\n\nvec3 background(const Ray ray) {\n  // A simple implicit sky that can be used for the background\n  return vec3(0.2) + vec3(0.8, 0.6, 0.5) * max(0.0, ray.direction.y);\n}\n\n// It seems to be a WebGL issue that the third parameter needs to be inout instea dof const on Tobias' machine\nvec3 shade(const Scene scene, const Ray ray, inout HitInfo hitInfo) {\n  \n  \tif(!hitInfo.hit) {\n  \t\treturn background(ray);\n  \t}\n  \n    vec3 shading = scene.ambient * hitInfo.material.diffuse;\n    for (int i = 0; i < lightCount; ++i) {\n        shading += shadeFromLight(scene, ray, hitInfo, scene.lights[i]); \n    }\n    return shading;\n}\n\n\nRay getFragCoordRay(const vec2 frag_coord) {\n  \tfloat sensorDistance = 1.0;\n  \tvec2 sensorMin = vec2(-1, -0.5);\n  \tvec2 sensorMax = vec2(1, 0.5);\n  \tvec2 pixelSize = (sensorMax- sensorMin) / vec2(viewport.x, viewport.y);\n  \tvec3 origin = vec3(0, 0, sensorDistance);\n    vec3 direction = normalize(vec3(sensorMin + pixelSize * frag_coord, -sensorDistance));  \n  \n  \treturn Ray(origin, direction);\n}\n\nfloat fresnel(const vec3 viewDirection, const vec3 normal) {\n#ifdef SOLUTION_FRESNEL\n\t// Put your code to compute the Fresnel effect here\n#else\n\treturn 1.0;\n#endif\n}\n\nvec3 colorForFragment(const Scene scene, const vec2 fragCoord) {\n      \n    Ray initialRay = getFragCoordRay(fragCoord);  \n  \tHitInfo initialHitInfo = intersectScene(scene, initialRay, 0.001, 10000.0);  \n  \tvec3 result = shade(scene, initialRay, initialHitInfo);\n\t\n  \tRay currentRay;\n  \tHitInfo currentHitInfo;\n  \t\n  \t// Compute the reflection\n  \tcurrentRay = initialRay;\n  \tcurrentHitInfo = initialHitInfo;\n  \t\n  \t// The initial strength of the reflection\n  \tfloat reflectionWeight = 1.0;\n  \t\n  \tconst int maxReflectionStepCount = 2;\n  \tfor(int i = 0; i < maxReflectionStepCount; i++) {\n      \n      if(!currentHitInfo.hit) break;\n      \n#ifdef SOLUTION_REFLECTION_REFRACTION\n  // Put your reflection weighting code here\n#else\n      \n#endif\n      \n#ifdef SOLUTION_FRESNEL\n#else\n      // Replace with Fresnel code\n      reflectionWeight *= 0.5;\n#endif\n      \n      Ray nextRay;\n#ifdef SOLUTION_REFLECTION_REFRACTION\n\t// Put your code to compute the reflection ray\n#else\n\t\n#endif\n      currentRay = nextRay;\n      \n      currentHitInfo = intersectScene(scene, currentRay, 0.001, 10000.0);      \n            \n      result += reflectionWeight * shade(scene, currentRay, currentHitInfo);\n    }\n  \n  \t// Compute the refraction\n  \tcurrentRay = initialRay;  \n  \tcurrentHitInfo = initialHitInfo;\n   \n  \t// The initial medium is air\n  \tfloat currentIOR = 1.0;\n\n  \t// The initial strength of the refraction.\n  \tfloat refractionWeight = 1.0;\n  \n  \tconst int maxRefractionStepCount = 2;\n  \tfor(int i = 0; i < maxRefractionStepCount; i++) {\n      \n#ifdef SOLUTION_REFLECTION_REFRACTION\n#else\n      // Replace with Fresnel code\n      reflectionWeight *= 0.5;      \n#endif\n\n#ifdef SOLUTION_FRESNEL\n#else\n      // Put Fresnel code here\n#endif      \n\n      Ray nextRay;\n\n\n#ifdef SOLUTION_REFLECTION_REFRACTION      \n\t  //This solution only expects the ray to be in one primitive at a time, and this is expected of student. \n\t  //That is, on exit it'll assume that the ray is in air.\n\t  // Put your code to compute the reflection ray and track the IOR\n#else\n\tfloat sourceIOR;\n\tfloat destIOR;\n\t\n#endif\n      currentHitInfo = intersectScene(scene, currentRay, 0.001, 10000.0);\n            \n      result += refractionWeight * shade(scene, currentRay, currentHitInfo);\n      \n      if(!currentHitInfo.hit) break;\n    }\n  return result;\n}\n\nMaterial getDefaultMaterial() {\n#ifdef SOLUTION_MATERIAL\n#else\n  return Material(vec3(0.3), vec3(0), 1.0);\n#endif\n}\n\nMaterial getPaperMaterial() {\n#ifdef SOLUTION_MATERIAL\n  // Replace by your definition of a paper material\n#else\n  return getDefaultMaterial();\n#endif\n}\n\nMaterial getPlasticMaterial() {\n#ifdef SOLUTION_MATERIAL\n  // Replace by your definition of a plastic material\n#else\n  return getDefaultMaterial();\n#endif\n}\n\nMaterial getGlassMaterial() {\n#ifdef SOLUTION_MATERIAL\n  // Replace by your definition of a glass material\n#else\n  return getDefaultMaterial();\n#endif\n}\n\nMaterial getSteelMirrorMaterial() {\n#ifdef SOLUTION_MATERIAL\n  // Replace by your definition of a steel mirror material\n#else\n  return getDefaultMaterial();\n#endif\n}\n\nvec3 tonemap(const vec3 radiance) {\n  const float monitorGamma = 2.0;\n  return pow(radiance, vec3(1.0 / monitorGamma));\n}\n\nvoid main()\n{\n    // Setup scene\n    Scene scene;\n  \tscene.ambient = vec3(0.12, 0.15, 0.2);\n  \n    // Lights\n    scene.lights[0].position = vec3(5, 15, -5);\n    scene.lights[0].color    = 0.5 * vec3(0.9, 0.5, 0.1);\n    \n  \tscene.lights[1].position = vec3(-15, 5, 2);\n    scene.lights[1].color    = 0.5 * vec3(0.1, 0.3, 1.0);\n  \n    // Primitives\n    scene.spheres[0].position            \t= vec3(10, -5, -16);\n    scene.spheres[0].radius              \t= 6.0;\n    scene.spheres[0].material \t\t\t\t= getPaperMaterial();\n    \n  \tscene.spheres[1].position            \t= vec3(-7, -2, -13);\n    scene.spheres[1].radius             \t= 4.0;\n    scene.spheres[1].material\t\t\t\t= getPlasticMaterial();\n  \n    scene.spheres[2].position            \t= vec3(0, 0.5, -5);\n    scene.spheres[2].radius              \t= 2.0;\n    scene.spheres[2].material   \t\t\t= getGlassMaterial();\n\n  \tscene.planes[0].normal            \t\t= normalize(vec3(0, 0.8, 0));\n  \tscene.planes[0].d              \t\t\t= -4.5;\n    scene.planes[0].material\t\t\t\t= getSteelMirrorMaterial();\n  \n  \tscene.cylinders[0].position            \t= vec3(-1, 1, -26);\n  \tscene.cylinders[0].direction            = normalize(vec3(-2, 2, -1));\n  \tscene.cylinders[0].radius         \t\t= 1.5;\n    scene.cylinders[0].material\t\t\t\t= getPaperMaterial();\n  \n  \tscene.cylinders[1].position            \t= vec3(4, 1, -5);\n  \tscene.cylinders[1].direction            = normalize(vec3(1, 4, 1));\n  \tscene.cylinders[1].radius         \t\t= 0.4;\n    scene.cylinders[1].material\t\t\t\t= getPlasticMaterial();\n\n  // compute color for fragment\n  gl_FragColor.rgb = tonemap(colorForFragment(scene, gl_FragCoord.xy));\n  gl_FragColor.a = 1.0;\n\n}\n`,\n\t\tdescription: ``,\n\t\twrapFunctionStart: ``,\n\t\twrapFunctionEnd: ``\n\t});\n\n\tUI.tabs.push(\n\t\t{\n\t\tvisible: false,\n\t\ttype: `x-shader/x-vertex`,\n\t\ttitle: `RaytracingDemoVS - GL`,\n\t\tid: `RaytracingDemoVS`,\n\t\tinitialValue: `attribute vec3 position;\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n  \n    void main(void) {\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n`,\n\t\tdescription: ``,\n\t\twrapFunctionStart: ``,\n\t\twrapFunctionEnd: ``\n\t});\n\n\t return UI; \n}//!setup\n\nvar gl;\nfunction initGL(canvas) {\n\ttry {\n\t\tgl = canvas.getContext(\"experimental-webgl\");\n\t\tgl.viewportWidth = canvas.width;\n\t\tgl.viewportHeight = canvas.height;\n\t} catch (e) {\n\t}\n\tif (!gl) {\n\t\talert(\"Could not initialise WebGL, sorry :-(\");\n\t}\n}\n\nfunction getShader(gl, id) {\n\tvar shaderScript = document.getElementById(id);\n\tif (!shaderScript) {\n\t\treturn null;\n\t}\n\n\tvar str = \"\";\n\tvar k = shaderScript.firstChild;\n\twhile (k) {\n\t\tif (k.nodeType == 3) {\n\t\t\tstr += k.textContent;\n\t\t}\n\t\tk = k.nextSibling;\n\t}\n\n\tvar shader;\n\tif (shaderScript.type == \"x-shader/x-fragment\") {\n\t\tshader = gl.createShader(gl.FRAGMENT_SHADER);\n\t} else if (shaderScript.type == \"x-shader/x-vertex\") {\n\t\tshader = gl.createShader(gl.VERTEX_SHADER);\n\t} else {\n\t\treturn null;\n\t}\n\n    console.log(str);\n\tgl.shaderSource(shader, str);\n\tgl.compileShader(shader);\n\n\tif (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n\t\talert(gl.getShaderInfoLog(shader));\n\t\treturn null;\n\t}\n\n\treturn shader;\n}\n\nfunction RaytracingDemo() {\n}\n\nRaytracingDemo.prototype.initShaders = function() {\n\n\tthis.shaderProgram = gl.createProgram();\n\n\tgl.attachShader(this.shaderProgram, getShader(gl, \"RaytracingDemoVS\"));\n\tgl.attachShader(this.shaderProgram, getShader(gl, \"RaytracingDemoFS\"));\n\tgl.linkProgram(this.shaderProgram);\n\n\tif (!gl.getProgramParameter(this.shaderProgram, gl.LINK_STATUS)) {\n\t\talert(\"Could not initialise shaders\");\n\t}\n\n\tgl.useProgram(this.shaderProgram);\n\n\tthis.shaderProgram.vertexPositionAttribute = gl.getAttribLocation(this.shaderProgram, \"position\");\n\tgl.enableVertexAttribArray(this.shaderProgram.vertexPositionAttribute);\n\n\tthis.shaderProgram.projectionMatrixUniform = gl.getUniformLocation(this.shaderProgram, \"projectionMatrix\");\n\tthis.shaderProgram.modelviewMatrixUniform = gl.getUniformLocation(this.shaderProgram, \"modelViewMatrix\");\n}\n\nRaytracingDemo.prototype.initBuffers = function() {\n\tthis.triangleVertexPositionBuffer = gl.createBuffer();\n\tgl.bindBuffer(gl.ARRAY_BUFFER, this.triangleVertexPositionBuffer);\n\t\n\tvar vertices = [\n\t\t -1,  -1,  0,\n\t\t -1,  1,  0,\n\t\t 1,  1,  0,\n\n\t\t -1,  -1,  0,\n\t\t 1,  -1,  0,\n\t\t 1,  1,  0,\n\t ];\n\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n\tthis.triangleVertexPositionBuffer.itemSize = 3;\n\tthis.triangleVertexPositionBuffer.numItems = 3 * 2;\n}\n\nRaytracingDemo.prototype.drawScene = function() {\n\t\t\t\n\tvar perspectiveMatrix = new J3DIMatrix4();\t\n\tperspectiveMatrix.setUniform(gl, this.shaderProgram.projectionMatrixUniform, false);\n\n\tvar modelViewMatrix = new J3DIMatrix4();\t\n\tmodelViewMatrix.setUniform(gl, this.shaderProgram.modelviewMatrixUniform, false);\n\t\t\n\tgl.bindBuffer(gl.ARRAY_BUFFER, this.triangleVertexPositionBuffer);\n\tgl.vertexAttribPointer(this.shaderProgram.vertexPositionAttribute, this.triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\t\n\tgl.uniform2iv(gl.getUniformLocation(this.shaderProgram, \"viewport\"), [getRenderTargetWidth(), getRenderTargetHeight()]);\n\t\n\tgl.drawArrays(gl.TRIANGLES, 0, this.triangleVertexPositionBuffer.numItems);\n}\n\nRaytracingDemo.prototype.run = function() {\n\tthis.initShaders();\n\tthis.initBuffers();\n\n\tgl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);\n\tgl.clear(gl.COLOR_BUFFER_BIT);\n\n\tthis.drawScene();\n};\n\nfunction init() {\t\n\t\n\n\tenv = new RaytracingDemo();\t\n\tenv.run();\n\n    return env;\n}\n\nfunction compute(canvas)\n{\n    env.initShaders();\n    env.initBuffers();\n\n    gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    env.drawScene();\n}\n\n", "function setup()\n{\n\tUI = {};\n\tUI.tabs = [];\n\tUI.titleLong = 'Simple Camera';\n\tUI.titleShort = 'cameraSimple';\n\tUI.numFrames = 1000;\n\tUI.maxFPS = 24;\n\tUI.tabs.push(\n\t\t{\n\t\tvisible: true,\n\t\ttype: `x-shader/x-fragment`,\n\t\ttitle: `Ray Generation`,\n\t\tid: `RaytracingDemoFS`,\n\t\tinitialValue: `precision highp float;\n\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\n\nstruct Sphere {\n  vec3 position;\n  float radius;\n};\n\nuniform vec2 g_resolution;\n\nbool intersectSphere(const Sphere sphere, const Ray ray) {\n  vec3 toOrigin = ray.origin - sphere.position;\n  float a = dot(ray.direction, ray.direction);\n  float b = 2.0 * dot(toOrigin, ray.direction);\n  float c = dot(toOrigin, toOrigin) - sphere.radius * sphere.radius;\n  float discriminant = b * b - 4.0 * a * c;\n\n  if(discriminant < 0.0) return false;\n\n  float t0 = (-b - sqrt(discriminant)) / (2.0 * a);\n  float t1 = (-b + sqrt(discriminant)) / (2.0 * a);\n\n  return t0 > 0.0 || t1 > 0.0;\n}\n\nvec3 simpleCamera(const ivec2 pixelCoord) {\n  const int sphereCount = 2;\n\n  // Array of spheres\n  Sphere spheres[sphereCount];\n\n  // Initialize first sphere\n  spheres[0].position = vec3(0, -2, -10);\n  spheres[0].radius = 3.0;\n  // Initialize second sphere\n  spheres[1].position = vec3(3, -1, -5);\n  spheres[1].radius = 1.0;\n\n  float d = 1.0;\n\n  // Initialize a ray\n  Ray ray;\n  ray.origin = vec3(0, 0, d);\n\n  // Construct ray direction\n  vec2 windowMin = vec2(-0.5,-0.5);\n  vec2 windowMax = vec2(0.5,0.5);\n  float width = (windowMax.x - windowMin.x) / g_resolution.x;\n  float height = (windowMax.y - windowMin.y) / g_resolution.y;\n  // Do not need to add 0.5, gl_FragCoord contains pixel centers\n  ray.direction = vec3( windowMin.x + width * gl_FragCoord.x,\n                       \twindowMin.y + height * gl_FragCoord.y,\n                        -d);\n\n  // Correct for window aspect ratio\n  float aspect = g_resolution.x / g_resolution.y;\n  ray.direction = ray.direction * vec3(aspect,1,1);\n\n  // Visualize the direction as a color\n  // return ray.direction;\n\n  // Loop over all spheres\n  for(int i = 0; i < sphereCount; i++) {\n    // Test for intersection\n    if(intersectSphere(spheres[i], ray)) {\n      // Mark as white if it intersects\n      return vec3(1);\n    }\n  }\n  return vec3(0);\n}\n\nvoid main() {\n  gl_FragColor = vec4(simpleCamera(ivec2(gl_FragCoord.xy)), 1);\n}`,\n\t\tdescription: ``,\n\t\twrapFunctionStart: ``,\n\t\twrapFunctionEnd: ``\n\t});\n\n\tUI.tabs.push(\n\t\t{\n\t\tvisible: false,\n\t\ttype: `x-shader/x-vertex`,\n\t\ttitle: `Something we would not like to see`,\n\t\tid: `RaytracingDemoVS`,\n\t\tinitialValue: ` attribute vec3 position;\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n    void main(void) {\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }`,\n\t\tdescription: ``,\n\t\twrapFunctionStart: ``,\n\t\twrapFunctionEnd: ``\n\t});\n\n\t return UI; \n}//!setup\n\nvar gl;\nfunction initGL(canvas) {\n\ttry {\n\t\tgl = canvas.getContext(\"webgl\");\n\t\tgl.viewportWidth = canvas.width;\n\t\tgl.viewportHeight = canvas.height;\n\t} catch (e) {\n\t}\n\tif (!gl) {\n\t\talert(\"Could not initialise WebGL, sorry :-(\");\n\t}\n}\n\nfunction getShader(gl, id) {\n\tvar shaderScript = document.getElementById(id);\n\tif (!shaderScript) {\n\t\treturn null;\n\t}\n\n\tvar str = \"\";\n\tvar k = shaderScript.firstChild;\n\twhile (k) {\n\t\tif (k.nodeType == 3) {\n\t\t\tstr += k.textContent;\n\t\t}\n\t\tk = k.nextSibling;\n\t}\n\n\tvar shader;\n\tif (shaderScript.type == \"x-shader/x-fragment\") {\n\t\tshader = gl.createShader(gl.FRAGMENT_SHADER);\n\t} else if (shaderScript.type == \"x-shader/x-vertex\") {\n\t\tshader = gl.createShader(gl.VERTEX_SHADER);\n\t} else {\n\t\treturn null;\n\t}\n\n\tgl.shaderSource(shader, str);\n\tgl.compileShader(shader);\n\n\tif (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n\t\talert(gl.getShaderInfoLog(shader));\n\t\treturn null;\n\t}\n\n\treturn shader;\n}\n\nfunction RaytracingDemo() {\n}\n\nRaytracingDemo.prototype.initShaders = function() {\n\n\tthis.shaderProgram = gl.createProgram();\n\n\tgl.attachShader(this.shaderProgram, getShader(gl, \"RaytracingDemoVS\"));\n\tgl.attachShader(this.shaderProgram, getShader(gl, \"RaytracingDemoFS\"));\n\tgl.linkProgram(this.shaderProgram);\n\n\tif (!gl.getProgramParameter(this.shaderProgram, gl.LINK_STATUS)) {\n\t\talert(\"Could not initialise shaders\");\n\t}\n\n\tgl.useProgram(this.shaderProgram);\n\n\tthis.shaderProgram.vertexPositionAttribute = gl.getAttribLocation(this.shaderProgram, \"position\");\n\tgl.enableVertexAttribArray(this.shaderProgram.vertexPositionAttribute);\n\n\tthis.shaderProgram.projectionMatrixUniform = gl.getUniformLocation(this.shaderProgram, \"projectionMatrix\");\n    this.shaderProgram.modelviewMatrixUniform = gl.getUniformLocation(this.shaderProgram, \"modelViewMatrix\");\n\n    // Add resolution uniform\n    gl.uniform2f(\n\t\tgl.getUniformLocation(this.shaderProgram, \"g_resolution\"),\n\t\tgetRenderTargetWidth(),\n\t\tgetRenderTargetHeight());\n}\n\nRaytracingDemo.prototype.initBuffers = function() {\n\tthis.triangleVertexPositionBuffer = gl.createBuffer();\n\tgl.bindBuffer(gl.ARRAY_BUFFER, this.triangleVertexPositionBuffer);\n\n\tvar vertices = [\n\t\t -1,  -1,  0,\n\t\t -1,  1,  0,\n\t\t 1,  1,  0,\n\n\t\t -1,  -1,  0,\n\t\t 1,  -1,  0,\n\t\t 1,  1,  0,\n\t ];\n\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n\tthis.triangleVertexPositionBuffer.itemSize = 3;\n\tthis.triangleVertexPositionBuffer.numItems = 3 * 2;\n}\n\nRaytracingDemo.prototype.drawScene = function() {\n\n\tvar perspectiveMatrix = new J3DIMatrix4();\n\tperspectiveMatrix.setUniform(gl, this.shaderProgram.projectionMatrixUniform, false);\n\n\tvar modelViewMatrix = new J3DIMatrix4();\n\tmodelViewMatrix.setUniform(gl, this.shaderProgram.modelviewMatrixUniform, false);\n\n\tgl.bindBuffer(gl.ARRAY_BUFFER, this.triangleVertexPositionBuffer);\n\tgl.vertexAttribPointer(this.shaderProgram.vertexPositionAttribute, this.triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\n\tgl.drawArrays(gl.TRIANGLES, 0, this.triangleVertexPositionBuffer.numItems);\n}\n\nRaytracingDemo.prototype.run = function() {\n\tthis.initShaders();\n\tthis.initBuffers();\n\n\tgl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);\n\tgl.clear(gl.COLOR_BUFFER_BIT);\n\n\tthis.drawScene();\n};\n\nfunction init() {\n\n\n\tenv = new RaytracingDemo();\n\tenv.run();\n\n    return env;\n}\n\nfunction compute(canvas)\n{\n    env.initShaders();\n    env.initBuffers();\n\n    gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    env.drawScene();\n}\n", "function setup()\n{\n\tUI = {};\n\tUI.tabs = [];\n\tUI.titleLong = 'OpenGL';\n\tUI.titleShort = 'openGL';\n\tUI.numFrames = 1000;\n\tUI.maxFPS = 24;\n\tUI.tabs.push(\n\t\t{\n\t\tvisible: true,\n\t\ttype: `x-shader/x-fragment`,\n\t\ttitle: `Fragment Program`,\n\t\tid: `OpenGLDemoFS`,\n\t\tinitialValue: `precision highp float;\n\n// Incoming from the vertex shader\nvarying vec3 fragColor;\nvarying vec3 fragNormal;\nvarying vec3 fragPosition;\nvarying vec2 fragTexCoord;\nvarying vec3 cameraPosition;\n\nuniform sampler2D testTexture;\n\nvoid main() {\n\n  // Light parameters\n  vec3 ambientLightColor = vec3(0.2, 0.2, 0.3);\n  vec3 lightPosition = vec3(0.0, 16.0, -30.0);\n  vec3 lightColor = vec3(1.0, 0.8, 0.9);\n\n  // Material parameters\n  vec3 materialKa = fragColor;\n  vec3 materialKd = vec3(1.0, 1.0, 1.0) * fragColor;\n  vec3 materialKs = vec3(0.8, 0.8, 0.8);\n  float materialGlossiness = 20.0;\n\n  // Articulate material parameters by textures\n  //vec3 textureColor =  texture2D(testTexture, fragTexCoord).rgb;\n  //materialKa *= textureColor;\n  //materialKd *= textureColor;\n  //materialKs *= textureColor;\n\n  // Directions used for shading\n  vec3 L = normalize(lightPosition.xyz - fragPosition.xyz);\n  vec3 E = normalize(cameraPosition - fragPosition.xyz);\n  vec3 R = normalize(-reflect(L, fragNormal.xyz));\n\n  // Phong, written as diffuse and specular reflectance\n  vec3 diffuseReflectance = materialKd * max(dot(fragNormal.xyz, L), 0.0);\n  vec3 specularReflectance = materialKs * pow(max(dot(R, E), 0.0), materialGlossiness);\n\n  // Incoming light times reflectance is outgoing light, also add some ambient\n  vec3 color =\n    ambientLightColor * materialKa +\n    lightColor * (diffuseReflectance + specularReflectance);\n\n  gl_FragColor = vec4(color, 1.0);\n\n  // Visualize the tex coord\n  //gl_FragColor = vec4(fragTexCoord, 0, 1);\n\n  // Use texture\n  //gl_FragColor = vec4(texture2D(testTexture, fragTexCoord).rgb, 1);\n}`,\n\t\tdescription: ``,\n\t\twrapFunctionStart: ``,\n\t\twrapFunctionEnd: ``\n\t});\n\n\tUI.tabs.push(\n\t\t{\n\t\tvisible: true,\n\t\ttype: `x-shader/x-vertex`,\n\t\ttitle: `Vertex Program`,\n\t\tid: `OpenGLDemoVS`,\n\t\tinitialValue: `// Incoming from the array buffers\nattribute vec3 position;\nattribute vec3 color;\nattribute vec3 normal;\nattribute vec2 texCoord;\n\n// Outgoing to the fragment program\nvarying vec3 fragColor;\nvarying vec3 fragNormal;\nvarying vec3 fragPosition;\nvarying vec2 fragTexCoord;\nvarying vec3 cameraPosition;\n\n// The current time value, set in the rick() of the JS code\nuniform float time;\n\nmat4 computeProjectionMatrix(float fov, float aspect, float zNear, float zFar) {\n\n\tfloat deltaZ = zFar - zNear;\n\tfloat cotangent = cos(fov * 0.5) / sin(fov * 0.5);\n\n  \tmat4 projectionMatrix;\n  \tprojectionMatrix[0] = vec4(cotangent / aspect, 0.0, 0.0, 0.0);\n\tprojectionMatrix[1] = vec4(0.0, cotangent, 0.0, 0.0);\n\tprojectionMatrix[2] = vec4(0.0, 0.0, -(zFar + zNear) / deltaZ, -1.0);\n\tprojectionMatrix[3] = vec4(0.0, 0.0, -2.0 * zNear * zFar / deltaZ, 0.0);\n\n\treturn projectionMatrix;\n}\n\n// Used to generate a simple \"look-at\" camera.\nmat4 computeViewMatrix(vec3 VRP, vec3 TP, vec3 VUV) {\n  \t// The VPN is pointing away from the TP. Can also be modeled the other way around.\n  \tvec3 VPN = VRP - TP;\n  \t// Generate the camera axes.\n    vec3 n = normalize(VPN);\n    vec3 u = normalize(cross(VUV, n));\n    vec3 v = normalize(cross(n, u));\n\n\tmat4 modelViewMatrix;\n\tmodelViewMatrix[0] = vec4(u[0], v[0], n[0], 0);\n\tmodelViewMatrix[1] = vec4(u[1], v[1], n[1], 0);\n\tmodelViewMatrix[2] = vec4(u[2], v[2], n[2], 0);\n\tmodelViewMatrix[3] = vec4(- dot(VRP, u), - dot(VRP, v), - dot(VRP, n), 1);\n\n  \treturn modelViewMatrix;\n}\n\nvoid main(void) {\n  // Animate the camera position using a uniform variable\n  cameraPosition = 5.0 * vec3(sin(time), 0, cos(time)) + vec3(0, 3.0, 0);\n\n  // Animate each vertex position\n  vec3 position2 = position +\n    0.0 * 0.2 * vec3(\n      sin(0.4 * position.x + time * 0.5),\n      cos(0.6 * position.x + time * 0.2),\n      sin(0.8 * position.x + time * 0.3)\n    );\n\n  // Set the parameters for the look-at camera.\n  vec3 TP = vec3(0, 0, 0);\n  vec3 VRP = cameraPosition;\n  vec3 VUV = vec3(0, 1, 0);\n\n  // Compute the view matrix (covered in the slides).\n  mat4 viewMatrix = computeViewMatrix(VRP, TP, VUV);\n\n  // Compute the projection matrix. NOTE: this is not covered in general camera slides.\n  mat4 projectionMatrix = computeProjectionMatrix(0.6, 2.0, 0.5, 200.0);\n\n  // A vertex shader *must* write to this value, otherwise the vertex wil not know where to go on screen\n  gl_Position = projectionMatrix * viewMatrix * vec4(position2, 1.0);\n\n  // Pass on information to the fragment program\n  fragColor = color;\n  fragNormal = normal;\n  fragPosition = position;\n  fragTexCoord = texCoord;\n}`,\n\t\tdescription: ``,\n\t\twrapFunctionStart: ``,\n\t\twrapFunctionEnd: ``\n\t});\n\n\tUI.tabs.push(\n\t\t{\n\t\tvisible: true,\n\t\ttype: `text/javascript`,\n\t\ttitle: `OpenGL`,\n\t\tid: `DemoJS`,\n\t\tinitialValue: `function getVertices() {\n  var size = 1.0;\n  return [\n    // Front face\n    -size, -size,  -size,\n    +size, -size,  -size,\n    +size, +size,  -size,\n    -size, +size,  -size,\n\n    // Back face\n    -size, -size, +size,\n    -size, +size, +size,\n    +size, +size, +size,\n    +size, -size, +size,\n\n    // Front face\n    -size, -size,  -size,\n    +size, -size,  -size,\n    +size, -size,  +size,\n    -size, -size,  +size,\n\n    // Back face\n    -size, +size, -size,\n    -size, +size, +size,\n    +size, +size, +size,\n    +size, +size, -size,\n\n    // Front face\n    -size, -size,  -size,\n    -size, -size,  +size,\n    -size, +size,  +size,\n    -size, +size,  -size,\n\n    // Back face\n    +size, -size, +size,\n    +size, +size, +size,\n    +size, +size, -size,\n    +size, -size, -size,\n  ];\n}\n\nfunction getColors() {\n return [\n   // Front face\n   1.0, 0.7, 0.0,\n   1.0, 0.7, 0.0,\n   1.0, 0.7, 0.0,\n   1.0, 0.7, 0.0,\n   // Back face\n   0.0, 1.0, 0.2,\n   0.0, 1.0, 0.2,\n   0.0, 1.0, 0.2,\n   0.0, 1.0, 0.2,\n   // Top face\n   0.4, 0.1, 1.0,\n   0.4, 0.1, 1.0,\n   0.4, 0.1, 1.0,\n   0.4, 0.1, 1.0,\n   // Bottom fac\n   1.0, 0.6, 0.3,\n   1.0, 0.6, 0.3,\n   1.0, 0.6, 0.3,\n   1.0, 0.6, 0.3,\n   // Right\n   0.0, 0.7, 1.0,\n   0.0, 0.7, 1.0,\n   0.0, 0.7, 1.0,\n   0.0, 0.7, 1.0,\n   // Left\n   1.0, 0.0, 1.0,\n   1.0, 0.0, 1.0,\n   1.0, 0.0, 1.0,\n   1.0, 0.0, 1.0\n ];\n}\n\nfunction getNormals() {\n    return [\n      // Front face\n      0.0, 0.0, 1.0,\n      0.0, 0.0, 1.0,\n      0.0, 0.0, 1.0,\n      0.0, 0.0, 1.0,\n      // Back face\n      0.0, 0.0, -1.0,\n      0.0, 0.0, -1.0,\n      0.0, 0.0, -1.0,\n      0.0, 0.0, -1.0,\n      // Top face\n      0.0, 1.0, 0.0,\n      0.0, 1.0, 0.0,\n      0.0, 1.0, 0.0,\n      0.0, 1.0, 0.0,\n      // Bottom face\n      0.0, -1.0, 0.0,\n      0.0, -1.0, 0.0,\n      0.0, -1.0, 0.0,\n      0.0, -1.0, 0.0,\n      // Right\n      1.0, 0.0, 0.0,\n      1.0, 0.0, 0.0,\n      1.0, 0.0, 0.0,\n      1.0, 0.0, 0.0,\n      // Left\n      -1.0, 0.0, 0.0,\n      -1.0, 0.0, 0.0,\n      -1.0, 0.0, 0.0,\n      -1.0, 0.0, 0.0\n    ];\n}\n\nfunction getTexCoords() {\nreturn [\n      // Front face\n      0.0, 0.0,\n      1.0, 0.0,\n      1.0, 1.0,\n      0.0, 1.0,\n\n      // Back face\n      1.0, 0.0,\n      1.0, 1.0,\n      0.0, 1.0,\n      0.0, 0.0,\n\n      // Top face\n      0.0, 1.0,\n      0.0, 0.0,\n      1.0, 0.0,\n      1.0, 1.0,\n\n      // Bottom face\n      1.0, 1.0,\n      0.0, 1.0,\n      0.0, 0.0,\n      1.0, 0.0,\n\n      // Right face\n      1.0, 0.0,\n      1.0, 1.0,\n      0.0, 1.0,\n      0.0, 0.0,\n\n      // Left face\n      0.0, 0.0,\n      1.0, 0.0,\n      1.0, 1.0,\n      0.0, 1.0,\n    ];\n}\n\nfunction getIndices() {\n    return [\n      2, 1, 0,      3, 2, 0,    // Front face\n      6, 5, 4,      7, 6, 4,    // Back face\n      8, 9, 10,     8, 10, 11,  // Top face\n      12, 13, 14,   12, 14, 15, // Bottom face\n      16, 17, 18,   16, 18, 19, // Right face\n      22, 21, 20,   23, 22, 20  // Left face\n    ];\n}\n\nfunction loadShaders() {\n  shaderProgram = gl.createProgram();\n\n  gl.attachShader(shaderProgram, getShader(gl, \"OpenGLDemoVS\"));\n  gl.attachShader(shaderProgram, getShader(gl, \"OpenGLDemoFS\"));\n  gl.linkProgram(shaderProgram);\n\n  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n    alert(\"Could not initialise shaders\");\n  }\n\n  gl.useProgram(shaderProgram);\n}\n\nfunction loadGeometry() {\n  // Positions\n  positionBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(getVertices()), gl.STATIC_DRAW);\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n  var positionAttributeLocation = gl.getAttribLocation(shaderProgram, \"position\");\n  gl.enableVertexAttribArray(positionAttributeLocation);\n  gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false,  0,   0);\n\n  // Colors\n  colorBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(getColors()), gl.STATIC_DRAW);\n  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\n  var colorAttributeLocation = gl.getAttribLocation(shaderProgram, \"color\");\n  gl.enableVertexAttribArray(colorAttributeLocation);\n  gl.vertexAttribPointer(colorAttributeLocation, 3, gl.FLOAT, false, 0, 0);\n\n  // Normals\n  normalBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(getNormals()), gl.STATIC_DRAW);\n  gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);\n  var normalAttributeLocation = gl.getAttribLocation(shaderProgram, \"normal\");\n  gl.enableVertexAttribArray(normalAttributeLocation);\n  gl.vertexAttribPointer(normalAttributeLocation, 3, gl.FLOAT,  false,  0,  0);\n\n  // Texture Coords (UVs)\n  texCoordBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(getTexCoords()), gl.STATIC_DRAW);\n  gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);\n  var texCoordAttributeLocation = gl.getAttribLocation(shaderProgram, \"texCoord\");\n  gl.enableVertexAttribArray(texCoordAttributeLocation);\n  gl.vertexAttribPointer(texCoordAttributeLocation, 2, gl.FLOAT,  false,  0,  0);\n\n  // Indices\n  triangleBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, triangleBuffer);\n  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(getIndices()), gl.STATIC_DRAW);\n  triangleBuffer.itemSize = 1;\n  triangleBuffer.numItems = 2 * 3 * 6;\n}\n\nfunction draw() {\n\n  gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);\n\n  gl.clearColor(0.3, 0.3, 0.3, 1.0);\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n  //gl.disable(gl.DEPTH_TEST);\n  gl.enable(gl.DEPTH_TEST);\n\n  gl.disable(gl.CULL_FACE);\n  //gl.enable(gl.CULL_FACE);\n\n  gl.cullFace(gl.BACK);\n  //gl.cullFace(gl.FRONT);\n\n  gl.disable(gl.BLEND);\n  //gl.enable(gl.BLEND);\n\n  gl.blendFunc(gl.ONE, gl.ONE);\n\n  // Use the texture \"texture\"\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n\n  // Update the uniform variable \"time\" with the current time\n  // getTime is implemented by our framework and returns time in milliseconds\n  gl.uniform1f(gl.getUniformLocation(shaderProgram, \"time\"), getTime());\n\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, triangleBuffer);\n  gl.drawElements(gl.TRIANGLES, triangleBuffer.numItems, gl.UNSIGNED_SHORT, 0);\n}\n\n// This function is caled once the image finished loading\nfunction handleLoadedTexture(texture) {\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, texture.image);\n  gl.generateMipmap(gl.TEXTURE_2D);\n  gl.bindTexture(gl.TEXTURE_2D, null);\n}\n\nfunction loadTexture() {\n  gl.enable(gl.TEXTURE_2D);\n  texture  = gl.createTexture();\n\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n  // Linear filtering\n  //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n\n  // MIP  filtering\n  //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n\n  // Load texture from memory\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([\n    10, 50, 200, 255,\n    10, 100, 50, 255,\n    10, 20, 30, 255,\n    200, 50, 100, 255,\n  ]));\n\n  // Load texture.\n  // .image is a HTML image we add to the variable to be used once it had finished loading\n  texture.image = new Image();\n  texture.image.onload = function() {\n    handleLoadedTexture(texture);\n  }\n  //texture.image.src = \"http://cg.cs.ucl.ac.uk/images/texture.jpg\";\n}\n\nfunction tick() {\n  // Draw the scene\n  draw();\n\n  // Requests this function to be called on the next possible occasion\n  // This is a HTML function, not anything WebGL-specific\n  requestAnimationFrame(tick);\n}\n\n// Initialization\nloadShaders();\nloadGeometry();\nloadTexture();\n\n// Request to tick. tick() itself will ask HTML to be called again\nif (!tickHasBeenCalled) {\n\ttickHasBeenCalled = true;\n\ttick();\n}\n`,\n\t\tdescription: ``,\n\t\twrapFunctionStart: ``,\n\t\twrapFunctionEnd: ``\n\t});\n\n\t return UI; \n}//!setup\n\nvar gl;\nfunction initGL(canvas) {\n\ttry {\n\t\tgl = canvas.getContext(\"webgl\");\n\t\tgl.viewportWidth = canvas.width;\n\t\tgl.viewportHeight = canvas.height;\n\t} catch (e) {\n\t}\n\tif (!gl) {\n\t\talert(\"Could not initialise WebGL, sorry :-(\");\n\t}\n}\n\nfunction getShader(gl, id) {\n\tvar shaderScript = document.getElementById(id);\n\tif (!shaderScript) {\n\t\treturn null;\n\t}\n\n\tvar str = \"\";\n\tvar k = shaderScript.firstChild;\n\twhile (k) {\n\t\tif (k.nodeType == 3) {\n\t\t\tstr += k.textContent;\n\t\t}\n\t\tk = k.nextSibling;\n\t}\n\n\tvar shader;\n\tif (shaderScript.type == \"x-shader/x-fragment\") {\n\t\tshader = gl.createShader(gl.FRAGMENT_SHADER);\n\t} else if (shaderScript.type == \"x-shader/x-vertex\") {\n\t\tshader = gl.createShader(gl.VERTEX_SHADER);\n\t} else {\n\t\treturn null;\n\t}\n\n\tgl.shaderSource(shader, str);\n\tgl.compileShader(shader);\n\n\tif (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n\t\talert(gl.getShaderInfoLog(shader));\n\t\treturn null;\n\t}\n\n\treturn shader;\n}\n\nfunction RaytracingDemo() {\n}\n\nfunction evalJS(id) {\n\n\ttry {\n\t\teval(document.getElementById(id).innerHTML);\n\t} catch (e) {\n\t\t\talert(e.message);\n\t}\n}\n\nvar count = 0;\nfunction getTime() {\nvar d = new Date();\nreturn d.getMinutes() * 60.0 + d.getSeconds() + d.getMilliseconds() / 1000.0;\n}\n\nvar tickHasBeenCalled = false;\nfunction init() {\n}\n\nfunction compute(canvas) {\n\tevalJS(\"DemoJS\");\n}\n"], "categories": ["CW", "Demos", "Demos"], "pictures": ["https://mfischer-ucl.github.io/uclcg/demos/thumb1.png", "https://mfischer-ucl.github.io/uclcg/demos/thumb2.png", "https://mfischer-ucl.github.io/uclcg/demos/thumb1.png"], "niceNames": ["Coursework1", "Camera Demo", "OpenGL Demo"], "shortDescriptions": ["CW1 Sample Test", "CAM DEMO Sample Text", "OGL Demo sample text"], "authors": ["MF", "MF", "MF"], "hidden": ["false", "false", "false"]}